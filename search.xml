<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[开源项目的学习-基于Java的Halo博客系统]]></title>
    <url>%2F2019%2F05%2F29%2F%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8EJava%E7%9A%84Halo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[玩转一个开源项目路线 了解项目是干什么的 了解项目的技术点 在本地跑起来 阅读源码并调试 能修改、添加功能模块 1.Halo是干什么的 阅读README.md文档是拿到每个项目的第一件事 通过readme文档知道Halo是基于Java的动态博客系统，意味着完全界面化的操作，在网页中写文章即可发布。 2.技术点 项目管理工具是Gradle 后端使用Spring Boot 这是作者的原话：Halo 的诞生离不开下面这些项目： Spring Boot：Spring 的快速开发框架 Freemarker：模板引擎，使页面静态化 H2 Database：嵌入式数据库，无需安装 Spring-data-jpa：不需要写 sql 语句的持久层框架 Ehcache：缓存框架 Lombok：让代码更简洁 oh-my-email：可能是最小的 Java 邮件发送库了，支持抄送、附件、模板等 Hutool：一个 Java 基础工具类库 Thumbnailator：缩略图生成库 AdminLTE：基于 Bootstrap 的后台模板 Bootstrap：使用最广泛的前端 ui 框架 Animate：非常好用的 css 动效库 SimpleMDE - Markdown Editor：简洁，功能够用，且轻量级的 Markdown 编辑器 Bootstrap-FileInput：基于 Bootstrap 的文件上传组件 Font-awesome：使用最广泛的字体图标库 JQuery：使用最广泛的 JavaScript 框架 Layer：个人认为最实用最好看的弹出层组件，没有之一 JQuery-Toast：消息提示组件 Pjax：pushState + ajax = pjax OwO：前端表情库 3.本地启动 在Github克隆Halo项目git clone https://github.com/halo-dev/halo.git 打开IntelliJ IDEA导入项目初次导入，要加载很久，耐心等待吧，导入完成后如下： 点击运行，浏览器输入运行成功后给出的地址 源码解读1.项目结构这是一个基于Spring Boot的项目 首先看项目管理文件build.gradle文件是项目管理文件，里面有各种依赖（dependencies），Maven则是以xml形式的各种依赖。 再看src目录其他不用管，src目录下的就是源码，其中test目录下为测试用，可以不用看resources为资源文件主要是一些前端的东西，可以打开看一下。其中application.yaml为配置文件，例如端口号什么的，可以进行修改。main为Java代码文件找到入口：这里是Application文件 接下来先看controller(控制层)，再看service层(服务层)，一个对应一个，慢慢看下去。需要耐心。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Java</tag>
        <tag>IDEA</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库学习(持续更新中···)]]></title>
    <url>%2F2019%2F05%2F29%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%C2%B7%C2%B7%C2%B7%2F</url>
    <content type="text"><![CDATA[数据库简介 关系型数据库： 基于E-R模型（实体-关系） 使用sql语句进行操作 分类：文档型（sqlite：移动终端）、服务型 数据库设计： 三范式：列不可拆分（数据拆到不能再拆，具体问题具体分析）、唯一标识（保证唯一性）、引用主键（引用唯一标识建立关系）； 关系及储存： 1对1：一个对象A对应一个对象B，一个对象B对应一个对象A eg：一个班级只有一个学生，一个学生对应着一个班级。则关系可以存入A或B对象中都可以； 1对多：一个对象A对应着n个对象B，一个对象B对应着一个对象A eg：一个班级有n个学生，一个学生对应着一个班级。则关系存入B对象（多）； 多对多：一个对象A对应n个对象B，一个对象B对应m个对象A 。则新建表AB，专门存关系，用标识填充数据。 数据库语法基本语句 入门 连接服务器 ：mysql -u 用户名 -p 密码 查看所有库： show database 选库语句：use 库名； 查看库下的表：show tables； 查看表结构：desc class； 创建数据库：create database 库名 charset utf8； 删除数据库：drop database 库名； MySQL中表、列可以改名，database不能改名 建表：create table stu（Snum int，Sname varchar(10)) engine myisam charset utf8; 删除表：drop table stu； 给表改名：rename table stu to newstu; 插入语句：insert into stu values (1,&#39;zhangsan&#39;),(2,&#39;lisi&#39;),(3,&#39;wangwu&#39;); 查询语句：select * from stu； 清空表数据：truncate stu； 增删改查(基本) 建表：CREATE语句 123456789CREATE TABLE `test`.`class` (`id` int(255) NOT NULL AUTO_INCREMENT,`sname` varchar(10) CHARACTER SET utf8 NOT NULL DEFAULT &apos;&apos;,`gender` char(1) CHARACTER SET utf8 NOT NULL DEFAULT &apos;&apos;,`company` varchar(20) CHARACTER SET utf8 NOT NULL DEFAULT &apos;&apos;,`salary` decimal(6, 2) NOT NULL DEFAULT &apos;&apos;,`fanbu` smallint(20) NOT NULL DEFAULT &apos;&apos;,PRIMARY KEY (`id`)); 添加语句：INSERT语句 1INSERT INTO `test`.`class`(`sname`, `gender`, `salary`, `fanbu`) VALUES (&apos;李四&apos;, &apos;男&apos;, 5000.00, 200)； 如果插入所有列，则可以不声明列名：INSERT INTO test.class VALUES (3,’zlatan’, ‘男’,’Blibli’ ,8000.00, 500);注意：id虽然为自增型，但是插入的时候还是要写，或者写null占位；插入多行用逗号隔开； 修改语句：UPDATE语句12update 表名 set 列1=新值，列2=新值 where id=4；UPDATE test.class SET fanbu=159 WHERE &apos;gender&apos;=&apos;男&apos; AND &apos;salary&apos;&gt;8000.00; where 表达式为真则执行生效，不一定为id，一定要加生效行，不然这一列全改了，问题很严重 删除语句：DELETE1delete from class where salary&gt;8500 删除是指删除整行 查询语句：SELECT语句123select sname,fanbu from class where id=3; //取部分列，单行；select *from class //取所有行所有列，*代表所有列，表名后不加where条件，则选所有行；select sanme，fanbu from class //取部分列，所有行； 字段类型（建表用）列类型：不同的列类型，所占据的空间和效率是不一样的，主要讨论列类型的存储范围与占据字节的关系 整型int系列声明时的参数（M）、unsigned 、zeroFill MySQL还支持选择在该类型关键字后面的括号内指定整数值的显示宽度(例如，INT(4))。该可选显示宽度规定用于显示宽度小于指定的列宽度的值时从左侧填满宽度。显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。 不加特殊说明时，默认有符号；加unsigned表示无符号，可以影响存储范围；M必需配合zeroFill使用才有意义：M表示补零宽度，和zerofill一起使用（保证位数相同），zerofill默认是unsigned类型；如添加一列类型为smallint的字段：alter table cd add num smallint(5) zerofill not null default 0 浮点型float（M，D）；decimal（M，D）M 叫标度—-&gt;代表总位数、D是精度—-&gt;代表小数点右边后的位数；decimal精度更高，float有时候会损失精度； 字符型 日期、时间类型 建表实战社交网站会员表 member 进阶语句对列的操作(alter table) 加一列在表的最后：alter table 表名 add 列名称 列类型 列参数； 加一列在指定列后：alter table 表名 add 列名称 列类型 列参数 after 某列； 加一列在表的最前面：alter table 表名 add 列名称 列类型 列参数 first； 删除列：alter table 表名 drop 列名； 修改列：alter table 表名 modify 列名 列类型 列参数----------modify不能改列名，要用change； 修改列名和列参数：alter table 表名 change 旧列名 新列名 列类型 列参数；查询语句(select) 查询模型： 列看成变量，where后面跟的是表达式，定位到列，一行一行的匹配判断，表达式为真则执行 既然是变量，就可以进行计算，即意味着可以组合成新的列进行查询显示 进阶查询 where条件查询 group by 分组 having 筛选 order by 排序 limit 限制结果条数 实战中练习商品表：goods字段：Goods_id、Cat_id、Goods_sn、Click_count、Goods_number、Market_price、Shop_price、Add_time、Is_best、Is_new、Is_hot把其他表的数据（shop.goods）插入到本表中(test.goods)1Insert into test.goods select Goods_id,Cat_id,Goods_sn,Click_count,Goods_number,Market_price,Shop_price,add_time,is_best,is_new,is_hot from shop.goods 基础查询where 1.1、查询商品主键为32的商品；Select goods_id,goods_name,shop_price from goods where goods_id=32; 1.2、不属于第3栏目的所有商品；Select goods_id,cat_id,goods_number from goods where cat_id !=3; !=等价于&lt;&gt; 1.3、本店价格高于和等于3000的商品；Select goods_id,goods_name,shop_price from goods where Shop_price&gt;=3000; 1.4、取出第4栏目和第11栏目的商品；Select goods_id,goods_name,shop_price from goods where cat_id in (4,11); //cat_id在4，11这个集合里都满足 1.4.1、取出不属于第3栏目且不属于第11栏目的商品；Select goods_id,goods_name,shop_price from goods where cat_id not in (3,11);Select goods_id,goods_name,shop_price from goods where cat_id !=3 and cat_id !=11 ; 1.5、取出价格在100到500之间的商品；Select goods_id,goods_name,shop_price from goods where Shop_price between 100 and 500； 1.6、取出价格大于100且小于300，或者大于4000且小于5000的商品；Select goods_id,goods_name,shop_price from goods where shop_price&gt;100 and shop_price&lt;300 or shop_price&gt;4000 and shop_price&lt;5000; //and优先级比or高 1.7、取出第3个栏目下价格小于1000或者大于3000，同时点击量大于等于5的商品；Select goods_id,goods_name,shop_price,click_count from goods where cat_id=3 and (shop_price&lt;1000 or shop_price&gt;3000) and click_count&gt;=5; 1.8、查出以“诺基亚”开头的商品；#模糊查询；Select goods_id,goods_name,shop_price,click_count from goods where goods_name like &#39;诺基亚%&#39;; //其中“%”能取出任意字符，“_”匹配单一字符Select goods_id,goods_name,shop_price,click_count from goods where goods_name like &#39;诺基亚N__&#39;; //查出诺基亚N加两个字符的商品 1.9、查出本店价格比市场价格的差值；Select goods_id,goods_name,market_price-shop_price from goods;Select goods_id,goods_name,(market_price-shop_price) as discount from goods; //以discount 显示Select goods_id,goods_name,(market_price-shop_price) as discount from goods where (market_price-shop_price)&gt;200; //查出差值大于200商品，where后不能是discount 练习题：有如下表和数组，把num值处于[20,29]之间，改为20，num值处于[30,39]之间的，改为30； 把num当成变量看，num/10取整，再乘以10 Update table set num=floor(num/10)*10 where num&gt;=20 and num&lt;=39;]]></content>
      <categories>
        <category>数据库</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大经典排序算法]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[十大经典排序算法排序算法是《数据结构与算法》中最基本的算法之一。排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括： 关于时间复杂度： 平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。 线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序； O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序 线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。 关于稳定性： 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 名词解释： n：数据规模 k：“桶”的个数 In-place：占用常数内存，不占用额外内存 Out-place：占用额外内存 稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同 GitBook 内容大纲 冒泡排序冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 动图演示 什么时候最快当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。 什么时候最慢当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。 Python 代码实现123456def bubbleSort(arr): for i in range(1, len(arr)): for j in range(0, len(arr)-i): if arr[j] &gt; arr[j+1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr Java 代码实现12345678910111213141516171819202122232425262728public class BubbleSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i &lt; arr.length; i++) &#123; // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 选择排序选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 动图演示 Python 代码实现1234567891011def selectionSort(arr): for i in range(len(arr) - 1): # 记录最小数的索引 minIndex = i for j in range(i + 1, len(arr)): if arr[j] &lt; arr[minIndex]: minIndex = j # i 不是最小数时，将 i 和最小数进行交换 if i != minIndex: arr[i], arr[minIndex] = arr[minIndex], arr[i] return arr Java 代码实现1234567891011121314151617181920212223242526272829public class SelectionSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 总共要经过 N-1 轮比较 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; // 记录目前能找到的最小值元素的下标 min = j; &#125; &#125; // 将找到的最小值和i位置所在的值进行交换 if (i != min) &#123; int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; &#125; &#125; return arr; &#125;&#125; 插入排序插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。 算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 动图演示 Python 代码实现123456789def insertionSort(arr): for i in range(len(arr)): preIndex = i-1 current = arr[i] while preIndex &gt;= 0 and arr[preIndex] &gt; current: arr[preIndex+1] = arr[preIndex] preIndex-=1 arr[preIndex+1] = current return arr Java 代码实现1234567891011121314151617181920212223242526272829public class InsertSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt; arr.length; i++) &#123; // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; // 存在比其小的数，插入 if (j != i) &#123; arr[j] = tmp; &#125; &#125; return arr; &#125;&#125; 希尔排序希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 算法步骤 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 Python 代码实现12345678910111213141516def shellSort(arr): import math gap=1 while(gap &lt; len(arr)/3): gap = gap*3+1 while gap &gt; 0: for i in range(gap,len(arr)): temp = arr[i] j = i-gap while j &gt;=0 and arr[j] &gt; temp: arr[j+gap]=arr[j] j-=gap arr[j+gap] = temp gap = math.floor(gap/3) return arr&#125; Java 代码实现12345678910111213141516171819202122232425262728public class ShellSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int gap = 1; while (gap &lt; arr.length) &#123; gap = gap * 3 + 1; &#125; while (gap &gt; 0) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int tmp = arr[i]; int j = i - gap; while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = tmp; &#125; gap = (int) Math.floor(gap / 3); &#125; return arr; &#125;&#125; 归并排序归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代； 在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为： However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。 说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。 算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 动图演示 Python 代码实现1234567891011121314151617181920def mergeSort(arr): import math if(len(arr)&lt;2): return arr middle = math.floor(len(arr)/2) left, right = arr[0:middle], arr[middle:] return merge(mergeSort(left), mergeSort(right))def merge(left,right): result = [] while left and right: if left[0] &lt;= right[0]: result.append(left.pop(0)); else: result.append(right.pop(0)); while left: result.append(left.pop(0)); while right: result.append(right.pop(0)); return result Java 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MergeSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); if (arr.length &lt; 2) &#123; return arr; &#125; int middle = (int) Math.floor(arr.length / 2); int[] left = Arrays.copyOfRange(arr, 0, middle); int[] right = Arrays.copyOfRange(arr, middle, arr.length); return merge(sort(left), sort(right)); &#125; protected int[] merge(int[] left, int[] right) &#123; int[] result = new int[left.length + right.length]; int i = 0; while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if (left[0] &lt;= right[0]) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; else &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; &#125; while (left.length &gt; 0) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; while (right.length &gt; 0) &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; return result; &#125;&#125; 快速排序快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案： 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 动图演示 Python 代码实现1234567891011121314151617181920212223def quickSort(arr, left=None, right=None): left = 0 if not isinstance(left,(int, float)) else left right = len(arr)-1 if not isinstance(right,(int, float)) else right if left &lt; right: partitionIndex = partition(arr, left, right) quickSort(arr, left, partitionIndex-1) quickSort(arr, partitionIndex+1, right) return arrdef partition(arr, left, right): pivot = left index = pivot+1 i = index while i &lt;= right: if arr[i] &lt; arr[pivot]: swap(arr, i, index) index+=1 i+=1 swap(arr,pivot,index-1) return index-1def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i] Java 代码实现12345678910111213141516171819202122232425262728293031323334353637383940public class QuickSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return quickSort(arr, 0, arr.length - 1); &#125; private int[] quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr; &#125; private int partition(int[] arr, int left, int right) &#123; // 设定基准值（pivot） int pivot = left; int index = pivot + 1; for (int i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index - 1; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 堆排序堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 堆排序的平均时间复杂度为 Ο(nlogn)。 算法步骤 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 动图演示 Python 代码实现123456789101112131415161718192021222324252627282930def buildMaxHeap(arr): import math for i in range(math.floor(len(arr)/2),-1,-1): heapify(arr,i)def heapify(arr, i): left = 2*i+1 right = 2*i+2 largest = i if left &lt; arrLen and arr[left] &gt; arr[largest]: largest = left if right &lt; arrLen and arr[right] &gt; arr[largest]: largest = right if largest != i: swap(arr, i, largest) heapify(arr, largest)def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i]def heapSort(arr): global arrLen arrLen = len(arr) buildMaxHeap(arr) for i in range(len(arr)-1,0,-1): swap(arr,0,i) arrLen -=1 heapify(arr, 0) return arr Java 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HeapSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0, len); &#125; return arr; &#125; private void buildMaxHeap(int[] arr, int len) &#123; for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) &#123; heapify(arr, i, len); &#125; &#125; private void heapify(int[] arr, int i, int len) &#123; int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest, len); &#125; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 计数排序计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 动图演示 Python 代码实现123456789101112131415def countingSort(arr, maxValue): bucketLen = maxValue+1 bucket = [0]*bucketLen sortedIndex =0 arrLen = len(arr) for i in range(arrLen): if not bucket[arr[i]]: bucket[arr[i]]=0 bucket[arr[i]]+=1 for j in range(bucketLen): while bucket[j]&gt;0: arr[sortedIndex] = j sortedIndex+=1 bucket[j]-=1 return arr Java 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041public class CountingSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxValue = getMaxValue(arr); return countingSort(arr, maxValue); &#125; private int[] countingSort(int[] arr, int maxValue) &#123; int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) &#123; bucket[value]++; &#125; int sortedIndex = 0; for (int j = 0; j &lt; bucketLen; j++) &#123; while (bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr; &#125; private int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125;&#125; 桶排序桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 什么时候最快当输入的数据可以均匀的分配到每一个桶中。 什么时候最慢当输入的数据被分配到了同一个桶中。 Java 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class BucketSort implements IArraySort &#123; private static final InsertSort insertSort = new InsertSort(); @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return bucketSort(arr, 5); &#125; private int[] bucketSort(int[] arr, int bucketSize) throws Exception &#123; if (arr.length == 0) &#123; return arr; &#125; int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) &#123; if (value &lt; minValue) &#123; minValue = value; &#125; else if (value &gt; maxValue) &#123; maxValue = value; &#125; &#125; int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); &#125; int arrIndex = 0; for (int[] bucket : buckets) &#123; if (bucket.length &lt;= 0) &#123; continue; &#125; // 对每个桶进行排序，这里使用了插入排序 bucket = insertSort.sort(bucket); for (int value : bucket) &#123; arr[arrIndex++] = value; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125; 基数排序基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 基数排序 vs 计数排序 vs 桶排序基数排序有两种方法： 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶； 计数排序：每个桶只存储单一键值； 桶排序：每个桶存储一定范围的数值； LSD 基数排序动图演示 Java 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 基数排序 * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9 */public class RadixSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxDigit = getMaxDigit(arr); return radixSort(arr, maxDigit); &#125; /** * 获取最高位数 */ private int getMaxDigit(int[] arr) &#123; int maxValue = getMaxValue(arr); return getNumLenght(maxValue); &#125; private int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125; protected int getNumLenght(long num) &#123; if (num == 0) &#123; return 1; &#125; int lenght = 0; for (long temp = num; temp != 0; temp /= 10) &#123; lenght++; &#125; return lenght; &#125; private int[] radixSort(int[] arr, int maxDigit) &#123; int mod = 10; int dev = 1; for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; for (int j = 0; j &lt; arr.length; j++) &#123; int bucket = ((arr[j] % mod) / dev) + mod; counter[bucket] = arrayAppend(counter[bucket], arr[j]); &#125; int pos = 0; for (int[] bucket : counter) &#123; for (int value : bucket) &#123; arr[pos++] = value; &#125; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrayAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序算法</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试基础]]></title>
    <url>%2F2019%2F05%2F26%2FJava%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1.写一个方法，实现字符串的反转，如：输入abc，输出cba1234567public static String reverse(String s)&#123; int length=s.length(); StringBuffer result=new StringBuffer(length); for(int i=length-1;i&gt;=0;i--) result.append(s.charAt(i)); return result.toString(); &#125; 2.数据类型之间的转换2.1如何将数值型字符转换为数字（Integer，Double） 使用Integer.parseInt()和Double.parseDouble()方法。2.2如何将数字转换为字符String.valueOf(int a); 3.如何取小数点前两位，并四舍五入12System.out.println("四舍五入取整:(3.856)=" + new BigDecimal(i).setScale(2, BigDecimal.ROUND_HALF_UP)); 4.文件和目录（I/O）操作 如何列出某个目录下的所有文件 如何列出某个目录下的所有子目录 判断一个文件或目录是否存在 如何读写文件123456789101112131415161718192021222324252627282930313233343536373839public static void main(String [] args) &#123; FileOpreate fo=new FileOpreate(); try &#123; //文件的写入 String[] testStr=new String[50]; for(int i=0;i&lt;testStr.length;i++) &#123; testStr[i]="我的测试数据00"+i; &#125; fo.writeFile("D:\\","test.txt",testStr); //创建或者删除文件 if(fo.createAndDeleteFile("D:\\","test001.txt")) &#123; fo.createAndDeleteFile("D:\\","test002.txt"); &#125; //创建或者删除文件夹 fo.createAndDeleteFolder("D:\\","2009-07-06"); //输出一个文件内的文件名称 fo.readFolderByFile("D:\\"); //判断一个文件是否是空的 fo.fileIsNull("D:\\","test002.txt"); //读取全部的文件内容 fo.readAllFile("D:\\","test.txt"); //一行一行读取文件内容 fo.readLineFile("D:\\","test.txt"); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; 5.编码转换，怎样实现将GB2312编码的字符串转换为ISO-8859-1编码的字符串String str = new String(&quot;字符串&quot;.getBytes(&quot;GB2312&quot;),&quot;ISO-8859-1&quot;); 6.谈谈final, finally, finalize的区别final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。finally是异常处理语句结构的一部分，表示总是执行。finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。 7.Int和Integer的区别Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。原始类型封装类boolean-Boolean char-Character byte-Byte short-Short int-Integer long-Long float-Float double-Double引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。 8.ArrayList和Vector的区别,HashMap和Hashtable的区别。ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差。 9.HashMap是怎样的结构？工作原理是什么？退化成链表解决方法？HashMap的本质仍然是数组，不过数组中存储的不是数据，而是一个链表的头节点。所以准确的说，其实现就是链表数组。HashMap中保存的是一个键值对，插入对象时必须提供一个键对象；查找对象时必须给定一个键对象（因此必须记住键）。键对象时不允许重复的，但是允许null空键的存在。HashMap插入对象时，根据给定的键key计算hashcode，然后再与数组长度进行求余运算得到数组下标。然后与该位置上的链表中已存储的键进行比较，对于已存在的键，则覆盖；对于不存在的键，则添加到链表尾。HashMap工作原理： HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用LinkedList来解决碰撞问题，当发生碰撞了，对象将会储存在LinkedList的下一个节点中。 HashMap在每个LinkedList节点中储存键值对对象。当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的LinkedList中。键对象的equals()方法用来找到键值对。key对象相同则覆盖，hashcode相同则添加到链表尾。退化成链表解决方法？JDK7中确实会有这样的问题，因为链表法有这样的缺陷。但是在JDK8中，Java会在链表长度超过一个阙值的时候将链表升级为一个平衡二叉树，使用hashcode作为树的分支变量，较大的会插入到右子树中；hashcode相等的情况下，HashMap希望Key对象是实现了Comparable接口的，这样就可以按照顺序插入。键对象的选择-&gt;选择String对象作为键对象最好，因为String具有不可变性。 10.什么是堆内存？什么是栈内存？有什么区别？Java的内存空间分为堆内存和栈内存。栈内存用于存储定义的基本类型变量、函数返回值、对象的引用等，而堆内存用于存放new出来的一切对象 11.Java里常用的工具类 org.apache.commons.io.IOUtils1、closeQuietly 关闭一个IO流、socket、或者selector且不抛出异常。通常放在finally块。2、toString 转换IO流、Uri、byte[]为String。3、copy IO流数据复制，从输入流写到输出流中，最大支持2GB。4、toByteArray 从输入流、URI获取byte[]。5、write 把字节、字符等写入输出流。6、toInputStream 把字符转换为输入流。7、readLines 从输入流中读取多行数据，返回List8、copyLarge 同copy，支持2GB以上数据的复制。9、lineIterator 从输入流返回一个迭代器，10、根据参数要求读取的数据量，全部读取，如果数据不够，则失败 org.apache.commons.io.FileUtils1、deleteDirectory 删除文件夹2、readFileToString 以字符形式读取文件内容。3、deleteQueitly 删除文件或文件夹且不会抛出异常。4、copyFile 复制文件5、writeStringToFile 把字符写到目标文件，如果文件不存在，则创建。6、forceMkdir 强制创建文件夹，如果该文件夹父级目录不存在，则创建父级。7、write 把字符写到指定文件中8、listFiles 列举某个目录下的文件(根据过滤器)9、copyDirectory 复制文件夹10、forceDelete 强制删除文件 org.apache.commons.io.FilenameUtils1、getExtension 返回文件后缀名2、getBaseName 返回文件名，不包含后缀名3、getName 返回文件全名4、concat 按命令行风格组合文件路径(详见方法注释)5、removeExtension 删除后缀名6、normalize 使路径正常化7、wildcardMatch 匹配通配符8、seperatorToUnix 路径分隔符改成unix系统格式的，即/9、getFullPath 获取文件路径，不包括文件名10、isExtension 检查文件后缀名是不是传入参数(List)中的一个 org.springframework.util.StringUtils1、hasText 检查字符串中是否包含文本2、hasLength 检测字符串是否长度大于03、isEmpty 检测字符串是否为空（若传入为对象，则判断对象是否为null）4、commaDelimitedStringToArray 逗号分隔的String转换为数组5、collectionToDelimitedString 把集合转为CSV格式字符串6、replace 替换字符串7、delimitedListToStringArray 相当于split8、uncapitalize 首字母小写9、collectionToDelimitedCommaString 把集合转为CSV格式字符串10、tokenizeToStringArray 和split基本一样，但能自动去掉空白的单词 org.apache.commons.lang.ArrayUtils1、contains 是否包含某字符串2、addAll 添加所有3、clone 克隆一个数组4、isEmpty 是否空数组5、add 向数组添加元素6、subarray 截取数组7、indexOf 查找下标8、isEquals 比较数组是否相等9、toObject 基础类型数据数组转换为对应的Object数组 org.apache.commons.codec.digest.DigestUtils1、md5Hex MD5加密，返回32位2、sha1Hex SHA-1加密3、sha256Hex SHA-256加密4、sha512Hex SHA-512加密5、md5 MD5加密，返回16位 org.apache.commons.collections.CollectionUtils1、isEmpty 是否为空2、select 根据条件筛选集合元素3、transform 根据指定方法处理集合元素，类似List的map()。4、filter 过滤元素，雷瑟List的filter()5、find 基本和select一样6、collect 和transform 差不多一样，但是返回新数组7、forAllDo 调用每个元素的指定方法。8、isEqualCollection 判断两个集合是否一致 12.JRE、JDK、JVM 及 JIT 之间有什么不同？JRE 代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用.JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。 13.ArrayList 与 LinkedList 的不区别？最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n) 14.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDownwn基本用法]]></title>
    <url>%2F2019%2F05%2F26%2FMarkDownwn%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[是什么md是一种标记语言，通过简单的标记语法，使得普通文本具有一定的格式。有专门的编辑器打开，但我使用的是VSCode，一款很强大的编辑器，必备工具。 怎么用 文本语法 标题：用#来标志，#越多，标题等级越低； 斜体：*斜体*； 粗体：**粗体**； 斜体加粗：*** 斜体加粗 *** ； 高亮：==高亮==； 删除线：删除线； 分割线：三个—或者三个***； 引用：用&gt;即可 ; 代码 代码行：反括号(tab上面的键) print(hello world) 代码块：用三个反括号包起来123public void main()&#123; system.out.printin(&quot;hello&quot;);&#125; 列表 无序列表：用 * 或 + 或 - 都行，推荐用星号，注意符号后面有空格 1 无序列表1 2 无序列表2 3 无序列表3 有序列表：数字. 列表名即可，如：1.有序列表 有序列表1 有序列表2 有序列表3特别注意，有序列表的序号是根据第一行列表的数字顺序来的 链接 超链接行内式：[超链接名](超链接地址 &quot;超链接title&quot;)参数式：[超链接名]：超链接地址 &quot;超链接title&quot;示例：百度一下 图片行内式：![图片描述](图片地址 &#39;&#39;图片title&#39;&#39;)参数试：[图片描述]：图片地址 &#39;&#39;图片title&#39;&#39; 表格 1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 注：第二行分割表头和内容。有一个就行，为了对齐，多加了几个。文字默认居左；两边加：表示文字居中；右边加：表示文字居右。 防坑1. 点(.)后面要加空格； 2. #后面要加空格； 3. 关键字符转义输出，需在关键字**前**加反斜杠\。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初衷]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%88%9D%E8%A1%B7%2F</url>
    <content type="text"><![CDATA[之前用Onenote，断断续续，零零散散记过一些笔记。希望这个blog能让我坚持下去。swag~ 经常会遇到一些问题，百度过后下次遇到继续百度，自己记录下来下次就好办多了 ^-^网上的回答需要自己整理，可靠性更强 ^^听说坚持记笔记，是一件很cool的事情 ^^]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建之路]]></title>
    <url>%2F2019%2F05%2F25%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[搭建远程博客三要素搭建个人博客=域名(外网可访问的地址)+外网服务器(外网存储文件图片的地方)+解析(本地与服务器做映射) Hexo是什么Hexo是基于JS的一个静态博客框架。静态博客：没有后端数据库加持，意味着页面上无功能模块，只能通过修改代码来修改页面功能和效果。所有文章以.md文件存储在本地电脑上。 安装Hexo框架 安装Git 安装Node.js直接去官网下载安装即可。安装完成后在命令终端输入git -vnode -vnpm -v 来检查是否安装配置成功说明：Node.js安装成功后，同时会自动安装一个包管理器，称为npm（Node Package Manager）。 npm是什么？npm是一个包管理器，发布者将自己的代码发布（npm publish）到代码仓库（registry），使用者将自己需要的包写入package.json文件中，到代码仓库中把代码下载（npm install）下来。 磁盘中新建一个文件夹Hexo/blog,我的是/d/Hexo/blog，这个路径就是以后启动 Git Bash here 的地方，以后出了问题也可以把blog文件夹下的 内容全部干掉重来。 输入如下命令：npm install -g cnpm --registry=https://registry.npm.taobao.org 完成后输入：cnpm -v 检查是否安装成功 由于npm代码仓库的服务器在国外，由于Great Firewall的缘故，下载速度可能不尽如人意，这时你可以使用淘宝的npm代码仓库，通过npm安装cnpm 下载Hexo框架到/d/Hexo/blog目录下输入命令：cnpm install -g hexo-cli 等待下载完成 本地使用 以下命令的执行路径全部都是/d/Hexo/blog 初始化一个博客，命令行输入hexo init 新建一篇博客，命令行输入hexo n &quot;我的第一篇博客&quot;这时在D:\Hexo\blog\source_posts下会生成一个我的第一篇博客.md文件，用编辑器打开即可写文章。 清理博客文件hexo clean 生成博客文件hexo g (g是generate) 启动博客文件hexo s (s是server，默认端口号是4000) 打开浏览器输入 http://localhost:4000 即可看到一个博客页面 以后修改完配置文件和写好文章后在本地 启动博客的一个流程都是123hexo cleanhexo ghexo s 远程部署一、本地+Github白嫖 生成github.io 仓库登录 github 创建仓库，仓库名称必须是 你的github账号名称.github.io 下载git部署插件，/Hexo/blog路径下命令行输入cnpm install --save hexo-deployer-git 修改站点配置_config.yaml文件deploy属性下修改为： 1234deploy: type: git repo: https://github.com/TIARAluan/TIARAluan.github.io.git branch: master 在之前本地启动的基础上加上一句 hexo d 将博客文件推到新建的github仓库中去 1234hexo cleanhexo ghexo dhexo s 部署成功后，浏览器输入 http://你的github账号名称.github.io 即可享用啦 二、买域名+租服务器]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Node.js</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java语法（持续更新···）]]></title>
    <url>%2F2019%2F03%2F30%2FJava%E8%AF%AD%E6%B3%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%C2%B7%C2%B7%C2%B7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[String类Java中将字符串作为对象来管理 1.声明字符串String str [null] eg:String s; 2.创建字符串用String类的构造方法 String（char a[]）方法123char a[]=&#123;'s','t','u','d','e','n','t'&#125;string s=new string(a,2,4)等价于String s= new String("uden") 3.连接字符串 连接多个字符串用“+”即可 连接其他数据类型结果：会将数据直接转换成字符串 4.获取字符串信息 获取长度str.length() 字符串查找 str.indexOf(substr) 返回值为索引位置 str.lastIndexOf(substr) 返回值为字符串最后出现的位置，若没有，返回-1 获取指定索引位置的字符str.charAt(int index) 5.字符串操作 获取子字符串 str.substring(int beginIndex) str.substring(int beginIndex,int endIndex) 去除空格str.trim() 字符串替换str.replace(char oldChar,char newChar) 大小写敏感，所有都会替换 判断开始与结尾str.startsWith(String prefix)`str.endWith(String suffix) 判断字符串是否相等不能简单的用==，因为比较运算符比较的是两个字符串的地址是否相同 str.equals(String otherstr) 前提是两个字符串具有相同的字符和长度 str.equalsIgnoreCase(String otherstr) 忽略大小写 按字典顺序比较两个字符串str.compareTo(String otherstr)str位于otherstr之前，返回负整数str位于otherstr之后，返回正整数相等，返回0； 大小写转换str.toLowerCase()str.toUpperCase() 字符串分割str.split(String sign)str.split(String sign,int limit) 格式化字符串str.format(String format,Object...args) 日期和时间字符串格式化Date date = new Date();String s = String.format(“%te”,date) %te表示一月中的某一天 6.正则表达式通常被用于判断语句中，用来检查某一字符串是否满足某一格式。正则表达式是含有一些具有特殊意义字符的字符串，这些字符被称为元字符 7.字符串生成器对于创建的字符串，他的长度是固定的，为了避免内存开销，产生了可变的字符序列StringBuilder类若要使StringBuilder最后输出字符串，可使用toString()方法 append()方法 用于追加内容 insert(int offset,arg)方法 用于指定位置插入数据 delete(int start,int end) 用于删除内容 练习：把字符串中的英文去掉答：使用正则表达式。元字符为\p{Alpha}把字符串倒序输出1.最容易想到的估计就是利用String类的toCharArray()，再倒序输出数组的方法2.不把字符串定义为String类，而是定义成一个StringBuffer类，用StringBuffer类中的reverse()方法直接倒序字符串]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>语法</tag>
      </tags>
  </entry>
</search>
