<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F06%2F22%2F09-%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[树结构的实际应用堆排序参考 基本介绍： 堆排序是利用堆 这种数据结构而设计的一种排序算法，堆排序是一种选择排序， 它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。 堆排序利用了顺序存储二叉树的思想，将数组转换成顺序存储二叉树再进行操作。 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆（没有要求结点的左孩子的值和右孩子的值的大小关系）。 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 一般升序采用大顶堆，降序采用小顶堆。 堆排序的基本思想： 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆 将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class HeapSort &#123; public static void main(String[] args) &#123; int[] array = &#123;4, 6, 8, 5, 9&#125;; sort(array); System.out.println(Arrays.toString(array)); &#125; public static void sort(int[] array) &#123; int temp = 0; // 将无序数组调整为大顶堆进行升序排列 for (int i = array.length / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(array, i, array.length); &#125; //1. 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端 //2. 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 for (int j = array.length - 1; j &gt; 0; j--) &#123; // 交换 temp = array[j]; array[j] = array[0]; array[0] = temp; // 将交换后的数列调整为大顶堆 adjustHeap(array, 0, j); &#125; &#125; /** * 将数组调整为大顶堆 * * @param array * @param i 非叶子节点对应的数组的索引，i从二叉树的最后一个非叶子节点开始（array.length/2-1） * @param length 表示对多少个元素进行调整，length在逐渐减少，第一次为数组的长度 */ public static void adjustHeap(int[] array, int i, int length) &#123; int temp = array[i]; // 当前元素的值 // k=i*2+1：表示当前节点的左子节点 for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; // 左子节点array[k]和右子节点比较array[k+1] if (k + 1 &lt; length &amp;&amp; array[k + 1] &gt; array[k]) &#123; k++; // 右子节点大，指向右子节点 &#125; // 若子节点大于父节点 if (array[k] &gt; temp) &#123; array[i] = array[k]; // 把较大的值赋给当前节点 i = k; // !!! i指向k，继续循环比较 &#125; else &#123; break; &#125; &#125; // for循环结束后，已经将以i为父节点的子树调整为大顶堆（局部） array[i] = temp; &#125;&#125; Huffman编码Huffman树 给定n个权值作为n个叶子结点，构造一棵二又树，若该树的带权路径长度（wpl）达到最小，称这样的二又树为最优二叉树，也称为哈夫曼树（Hufman Tree）。 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1 结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL（weighted path length），权值越大的结点离根结点越近的二叉树才是最优二叉树。 创建Huffman树给你一个数列{13, 7,8,3,29,6,1}，要求转成一棵Huffman树. 步骤： 从小到大进行排序，将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单的二叉树 取出根节点权值最小的两颗二叉树 组成一棵新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 再将这棵新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一棵Huffman树 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class HuffmanTree &#123; public static void main(String[] args) &#123; int[] array = &#123;13, 7, 8, 3, 29, 6, 1&#125;; Node huffmanTreeRoot = createHuffmanTree(array); System.out.println("Huffman根节点：" + huffmanTreeRoot); preOrder(huffmanTreeRoot); &#125; // 创建Huffman树 public static Node createHuffmanTree(int[] array) &#123; // 0. 为了处理方便，将array形成node，装在ArrayList中 List&lt;Node&gt; listNodes = new ArrayList&lt;Node&gt;(); for (Integer value : array) &#123; listNodes.add(new Node(value)); &#125; // 集合只有一个元素则说明构建Huffman树的过程已完成 while (listNodes.size() &gt; 1) &#123; // 1. 从小到大排序 Collections.sort(listNodes); //System.out.println("排序后" + listNodes); // 2. 取出根节点权值最小的两颗二叉树 Node leftNode = listNodes.get(0); Node rightNode = listNodes.get(1); // 3. 组成一棵新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 Node parent = new Node(leftNode.getValue() + rightNode.getValue()); parent.setLeft(leftNode); parent.setRight(rightNode); // 4. 将用过的节点从集合删除，并把新生的父节点加入到集合 listNodes.remove(leftNode); listNodes.remove(rightNode); listNodes.add(parent); &#125; // 返回Huffman树的根节点 return listNodes.get(0); &#125; public static void preOrder(Node root) &#123; if (root != null) &#123; root.preOrder(); &#125; else &#123; System.out.println("空树..."); return; &#125; &#125;&#125;//为了使用Collection的排序方法，实现Compare接口class Node implements Comparable&lt;Node&gt; &#123; private int value; //节点权值 private Node left; private Node right; public Node(int value) &#123; this.value = value; &#125; // 从小到大排序 public int compareTo(Node o) &#123; return this.value - o.value; &#125; // 前序遍历 public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125; public Node getLeft() &#123; return left; &#125; public void setLeft(Node left) &#123; this.left = left; &#125; public Node getRight() &#123; return right; &#125; public void setRight(Node right) &#123; this.right = right; &#125; @Override public String toString() &#123; return "Node&#123;" + "value=" + value + '&#125;'; &#125;&#125; Huffman编码Huffman编码广泛地用于数据文件压缩。其压缩率通常在20%~90%之间，它是可变字长编码（VLC）的一种。于1952年提出一种编码方法，称之为最佳编码。 原理分析： 定长编码： 变长编码： Huffman编码： 此编码满足前缀编码，即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性赫夫曼编码是无损处理方案 注意，这个赫夫曼树根据排序方法不同（生成的新的二叉树，权值有相等的情况），也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl是-样的，都是最小的，最后生成的赫夫曼编码的长度是一样。 压缩文件给定字符串“i like like like java do you like a java ”，根据Huffman编码原理，对其进行压缩（形式如：“1010000101010101101101101010101010001”） Node（data，weight，left，right） 12345678910111213141516class Node implements Comparable&lt;Node&gt; &#123; Byte data; // 存放数据(字符)本身，比如'a' =&gt; 97 ' ' =&gt; 32 int weight; //权值, 表示字符出现的次数 Node left;// Node right; public Node(Byte data, int weight) &#123; this.data = data; this.weight = weight; &#125; @Override public int compareTo(Node o) &#123; // 从小到大排序 return this.weight - o.weight; &#125;&#125; 统计字符串字符出现的次数—[Node[date=97 ,weight = 5], Node[data=32,weight = 9]……] 12345678910111213141516171819202122private static List&lt;Node&gt; getNodes(byte[] bytes) &#123; //1创建一个ArrayList ArrayList&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); //遍历 bytes , 统计 每一个byte出现的次数-&gt;map[key,value] Map&lt;Byte, Integer&gt; counts = new HashMap&lt;&gt;(); for (byte b : bytes) &#123; Integer count = counts.get(b); if (count == null) &#123; // Map还没有这个字符数据,第一次 counts.put(b, 1); &#125; else &#123; counts.put(b, count + 1); &#125; &#125; //把每一个键值对转成一个Node 对象，并加入到nodes集合 //遍历map for(Map.Entry&lt;Byte, Integer&gt; entry: counts.entrySet()) &#123; nodes.add(new Node(entry.getKey(), entry.getValue())); &#125; return nodes; &#125; 根据weight生成Huffman树 12345678910111213141516171819202122232425private static Node createHuffmanTree(List&lt;Node&gt; nodes) &#123; while(nodes.size() &gt; 1) &#123; //排序, 从小到大 Collections.sort(nodes); //取出第一颗最小的二叉树 Node leftNode = nodes.get(0); //取出第二颗最小的二叉树 Node rightNode = nodes.get(1); //创建一颗新的二叉树,它的根节点 没有data, 只有权值 Node parent = new Node(null, leftNode.weight + rightNode.weight); parent.left = leftNode; parent.right = rightNode; //将已经处理的两颗二叉树从nodes删除 nodes.remove(leftNode); nodes.remove(rightNode); //将新的二叉树，加入到nodes nodes.add(parent); &#125; //nodes 最后的结点，就是赫夫曼树的根结点 return nodes.get(0); &#125; 根据策略生成Huffman编码表—Map&lt;Byte,String&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合 * @param node 传入结点 * @param code 路径： 左子结点是 0, 右子结点 1 * @param stringBuilder 用于拼接路径 */ private static void getCodes(Node node, String code, StringBuilder stringBuilder) &#123; StringBuilder stringBuilder2 = new StringBuilder(stringBuilder); //将code 加入到 stringBuilder2 stringBuilder2.append(code); if(node != null) &#123; //如果node == null不处理 //判断当前node 是叶子结点还是非叶子结点 if(node.data == null) &#123; //非叶子结点 //递归处理 //向左递归 getCodes(node.left, "0", stringBuilder2); //向右递归 getCodes(node.right, "1", stringBuilder2); &#125; else &#123; //说明是一个叶子结点 //就表示找到某个叶子结点的最后 huffmanCodes.put(node.data, stringBuilder2.toString()); &#125; &#125; &#125; //生成赫夫曼树对应的赫夫曼编码 //思路: //1. 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式 // 生成的赫夫曼编码表&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125; //为了调用方便，我们重载 getCodes static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;Byte,String&gt;(); //2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子结点的路径 static StringBuilder stringBuilder = new StringBuilder(); private static Map&lt;Byte, String&gt; getCodes(Node root) &#123; if(root == null) &#123; return null; &#125; //处理root的左子树 getCodes(root.left, "0", stringBuilder); //处理root的右子树 getCodes(root.right, "1", stringBuilder); return huffmanCodes; &#125; 根据编码表将数据进行压缩 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[] /** * * @param bytes 这时原始的字符串对应的 byte[] * @param huffmanCodes 生成的赫夫曼编码map * @return 返回赫夫曼编码处理后的 byte[] * 举例： String content = "i like like like java do you like a java"; =》 byte[] contentBytes = content.getBytes(); * 返回的是 字符串 "1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100" * =&gt; 对应的 byte[] huffmanCodeBytes ，即 8位对应一个 byte,放入到 huffmanCodeBytes * huffmanCodeBytes[0] = 10101000(补码) =&gt; byte [推导 10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ] * huffmanCodeBytes[1] = -88 */ private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123; //1.利用 huffmanCodes 将 bytes 转成 赫夫曼编码对应的字符串 StringBuilder stringBuilder = new StringBuilder(); //遍历bytes 数组 for(byte b: bytes) &#123; stringBuilder.append(huffmanCodes.get(b)); &#125; //System.out.println("测试 stringBuilder~~~=" + stringBuilder.toString()); //将 "1010100010111111110..." 转成 byte[] //统计返回 byte[] huffmanCodeBytes 长度 //一句话 int len = (stringBuilder.length() + 7) / 8; int len; if(stringBuilder.length() % 8 == 0) &#123; len = stringBuilder.length() / 8; &#125; else &#123; len = stringBuilder.length() / 8 + 1; &#125; //创建 存储压缩后的 byte数组 byte[] huffmanCodeBytes = new byte[len]; int index = 0;//记录是第几个byte for (int i = 0; i &lt; stringBuilder.length(); i += 8) &#123; //因为是每8位对应一个byte,所以步长 +8 String strByte; if(i+8 &gt; stringBuilder.length()) &#123;//不够8位 strByte = stringBuilder.substring(i); &#125;else&#123; strByte = stringBuilder.substring(i, i + 8); &#125; //将strByte 转成一个byte,放入到 huffmanCodeBytes huffmanCodeBytes[index] = (byte)Integer.parseInt(strByte, 2); index++; &#125; return huffmanCodeBytes; &#125; 二叉排序树二叉排序树在进行增删改查的时候效率都比较高 基本介绍 二叉排序树： BST (Binary Sort(Search) Tree)，对于二叉排序树的任何-一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点 二叉排序树的创建和遍历（中序遍历） 12345678910111213141516171819202122232425262728293031323334class Node &#123; // 添加节点 public void add(Node node) &#123; if (node == null) &#123; return; &#125; // 判断要添加的节点和当前节点的大小关系 if (node.getValue() &lt; this.value) &#123; // 比当前节点小 if (this.left == null) &#123; //没有左子节点 this.left = node; &#125;else &#123; // 向左递归 this.getLeft().add(node); &#125; &#125; else &#123; // 比当前节点大或相等 if (this.right == null) &#123; //没有右子节点 this.right = node; &#125;else &#123; // 向右递归 this.getRight().add(node); &#125; &#125; &#125; // 中序遍历（输出有序） public void midOrder() &#123; if (this.left != null) &#123; this.left.midOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.midOrder(); &#125; &#125;&#125; 123456789101112131415161718class BinarySortTree &#123; private Node root; // 添加 public void add(Node node) &#123; if (root == null) &#123; root = node; &#125; else &#123; root.add(node); &#125; &#125; // 中序遍历 public void midOrder() &#123; if (root != null) &#123; root.midOrder(); &#125; &#125;&#125; 二叉排序树的删除 删除叶子节点 (1) 需求先去找到要删除的结点 targetNode (2) 找到targetNode 的 父结点 parent (3) 确定 targetNode 是 parent的左子结点 还是右子结点 (4) 根据前面的情况来对应删除 左子结点 parent.left = null 右子结点 parent.right = null; 删除只有一颗子树的节点 (1) 需求先去找到要删除的结点 targetNode (2) 找到targetNode 的 父结点 parent (3) 确定targetNode 的子结点是左子结点还是右子结点 (4) targetNode 是 parent 的左子结点还是右子结点 (5) 如果targetNode 有左子结点 \5. 1 如果 targetNode 是 parent 的左子结点 parent.left = targetNode.left; 5.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.left; (6) 如果targetNode 有右子结点 6.1 如果 targetNode 是 parent 的左子结点 parent.left = targetNode.right; 6.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right 删除有两颗子树的节点 (1) 需求先去找到要删除的结点 targetNode (2) 找到targetNode 的 父结点 parent (3) 从targetNode 的右子树找到最小的结点（从targetNode 的左子树找到最大的结点） (4) 用一个临时变量，将 最小结点的值保存 temp = 11 (5) 删除该最小结点 (6) targetNode.value = temp 代码实现： 找到待删除节点targetNode 123456789101112131415161718192021//查找要删除的结点 /** * @param value 希望删除的结点的值 * @return 如果找到返回该结点，否则返回null */ public Node search(int value) &#123; if(value == this.value) &#123; //找到就是该结点 return this; &#125; else if(value &lt; this.value) &#123;//如果查找的值小于当前结点，向左子树递归查找 //如果左子结点为空 if(this.left == null) &#123; return null; &#125; return this.left.search(value); &#125; else &#123; //如果查找的值不小于当前结点，向右子树递归查找 if(this.right == null) &#123; return null; &#125; return this.right.search(value); &#125; &#125; 找到待删除节点的父节点parent 123456789101112131415161718192021//查找要删除结点的父结点 /** * @param value 要找到的结点的值 * @return 返回的是要删除的结点的父结点，如果没有就返回null */ public Node searchParent(int value) &#123; //如果当前结点就是要删除的结点的父结点，就返回 if((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) &#123; return this; &#125; else &#123; //如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空 if(value &lt; this.value &amp;&amp; this.left != null) &#123; return this.left.searchParent(value); //向左子树递归查找 &#125; else if (value &gt;= this.value &amp;&amp; this.right != null) &#123; return this.right.searchParent(value); //向右子树递归查找 &#125; else &#123; return null; // 没有找到父结点 &#125; &#125; &#125; 删除节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//1. 返回的 以node 为根结点的二叉排序树的最小结点的值 //2. 删除node 为根结点的二叉排序树的最小结点 /** * @param node 传入的结点(当做二叉排序树的根结点) * @return 返回的 以node 为根结点的二叉排序树的最小结点的值 */ public int delRightTreeMin(Node node) &#123; Node target = node; //循环的查找左子节点，就会找到最小值 while(target.left != null) &#123; target = target.left; &#125; //这时 target就指向了最小结点 //删除最小结点 delNode(target.value); return target.value; &#125;//删除结点 public void delNode(int value) &#123; if(root == null) &#123; return; &#125;else &#123; //1.需求先去找到要删除的结点 targetNode Node targetNode = search(value); //如果没有找到要删除的结点 if(targetNode == null) &#123; return; &#125; //如果我们发现当前这颗二叉排序树只有一个结点 if(root.left == null &amp;&amp; root.right == null) &#123; root = null; return; &#125; //去找到targetNode的父结点 Node parent = searchParent(value); //如果要删除的结点是叶子结点 if(targetNode.left == null &amp;&amp; targetNode.right == null) &#123; //判断targetNode 是父结点的左子结点，还是右子结点 if(parent.left != null &amp;&amp; parent.left.value == value) &#123; //是左子结点 parent.left = null; &#125; else if (parent.right != null &amp;&amp; parent.right.value == value) &#123;//是由子结点 parent.right = null; &#125; &#125; else if (targetNode.left != null &amp;&amp; targetNode.right != null) &#123; //删除有两颗子树的节点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal; &#125; else &#123; // 删除只有一颗子树的结点 //如果要删除的结点有左子结点 if(targetNode.left != null) &#123; if(parent != null) &#123; //如果 targetNode 是 parent 的左子结点 if(parent.left.value == value) &#123; parent.left = targetNode.left; &#125; else &#123; // targetNode 是 parent 的右子结点 parent.right = targetNode.left; &#125; &#125; else &#123; root = targetNode.left; &#125; &#125; else &#123; //如果要删除的结点有右子结点 if(parent != null) &#123; //如果 targetNode 是 parent 的左子结点 if(parent.left.value == value) &#123; parent.left = targetNode.right; &#125; else &#123; //如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right; &#125; &#125; else &#123; root = targetNode.right; &#125; &#125; &#125; &#125; &#125; 平衡二叉树（AVL）二叉排序树可能存在的问题数列{1,2,3,4,5,6}， 要求创建- 颗二叉排序树(BST) 存在的问题： 左子树全部为空，从形式上看，更像一个单链表. 插入速度没有影响 查询速度明显降低（因为需要依次比较），不能发挥BST的优势，因为每次还需要比较左子树，其查询速度比单链表还慢。 解决方案：平衡二叉树 基本介绍 平衡二叉树也叫平衡二叉搜索树 ( Self-balancing binary search tree)又被称为AVL树，可以保证查询效率较高。 具有以下特点: 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 平衡二叉树的常用实现方法有红黑树、AVL、 替罪羊树、Treap、 伸展树等。 创建AVL在创建的时候根据不同的情况可以采用单旋转（左旋转、右旋转）和双旋转的方法来构建平衡二叉树 左旋转 当(右子树的高度-左子树的高度) &gt; 1时，进行左旋转 要求:给你一个数列{4,3,6,5,7,8}，创建出对应的平衡二叉树.数列 123456789101112131415//左旋转方法private void leftRotate() &#123; // 1.创建新的结点，以当前根结点的值 Node newNode = new Node(value); // 2.把新的结点的左子树设置成当前结点的左子树 newNode.left = left; // 3.把新的结点的右子树设置成带你过去结点的右子树的左子树 newNode.right = right.left; // 4.把当前结点的值替换成右子结点的值 value = right.value; // 5.把当前结点的右子树设置成当前结点右子树的右子树 right = right.right; // 6.把当前结点的左子树(左子结点)设置成新的结点 left = newNode;&#125; 右旋转 当(左子树的高度-右子树的高度) &gt; 1时，进行右旋转 要求:给你一个数列{10,12, 8, 9, 7,6}，创建出对应的平衡二叉树数列 123456789101112131415//右旋转private void rightRotate() &#123; // 1.创建新的结点，以当前根结点的值 Node newNode = new Node(value); // 2.把新的结点的右子树设置成当前结点的右子树 newNode.right = right; // 3.把新的结点的左子树设置成带你过去结点的左子树的右子树 newNode.left = left.right; // 4.把当前结点的值替换成左子结点的值 value = left.value; // 5.把当前结点的左子树设置成当前结点左子树的左子树 left = left.left; // 6.把当前结点的右子树(右子结点)设置成新的结点 right = newNode;&#125; 双旋转 前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转不能完成平衡二叉树的转换。 比如数列：int[]arr={ 10, 11,7,6,8,9}；运行原来的代码可以看到，并没有转成AVL树. int[] arr= {2,1,6,5,7,3}；运行原来的代码可以看到，并没有转成AVL树 创建平衡二叉树代码： 获取以该节点为根节点的树的高度 123public int height() &#123; return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1;&#125; 获取左右子树的高度 1234567891011121314// 返回左子树的高度public int leftHeight() &#123; if (left == null) &#123; return 0; &#125; return left.height();&#125;// 返回右子树的高度public int rightHeight() &#123; if (right == null) &#123; return 0; &#125; return right.height();&#125; 根据规则生成平衡二叉树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void add(Node node) &#123; if (node == null) &#123; return; &#125; // 判断传入的结点的值，和当前子树的根结点的值关系 if (node.value &lt; this.value) &#123; // 如果当前结点左子结点为null if (this.left == null) &#123; this.left = node; &#125; else &#123; // 递归的向左子树添加 this.left.add(node); &#125; &#125; else &#123; // 添加的结点的值大于 当前结点的值 if (this.right == null) &#123; this.right = node; &#125; else &#123; // 递归的向右子树添加 this.right.add(node); &#125; &#125; //当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转 if(rightHeight() - leftHeight() &gt; 1) &#123; //如果它的右子树的左子树的高度大于它的右子树的右子树的高度 if(right != null &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123; //先对右子结点进行右旋转 right.rightRotate(); //然后在对当前结点进行左旋转 leftRotate(); //左旋转.. &#125; else &#123; //直接进行左旋转即可 leftRotate(); &#125; return ; //必须要!!! &#125; //当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转 if(leftHeight() - rightHeight() &gt; 1) &#123; //如果它的左子树的右子树高度大于它的左子树的高度 if(left != null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123; //先对当前结点的左结点(左子树)-&gt;左旋转 left.leftRotate(); //再对当前结点进行右旋转 rightRotate(); &#125; else &#123; //直接进行右旋转即可 rightRotate(); &#125; &#125; &#125;多路查找树 多路查找树二叉树存在的问题： 多叉树： 在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树(multiway tree) B树B树通过重新组织节点，降低树的高度，并且减少io读写次数来提升效率。 如图B树通过重新组织节点，降低了树的高度 文件系统及数据库系统的设计者利用了磁盘预读原理,将一个节点的大小设为等于-一个页(页得大小通常为4k)，这样每个节点只需要一次I0就可以完全载入 将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中. 我们在学习Mysql时，经常听到说某种类型的索引是基于B树或者B+树的，如图: B-树的搜索， 从根结点开始，对结点内的关键字(有序)序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点 关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据. 搜索有可能在非叶子结点结束 其搜索性能等价于在关键字全集内做一次二分查找 B+树B+树是B树的一种变体 B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中(B树可以在非叶子结点命中)，其性能也等价于在关键字全集做一次二分查找 所有关键字都出现在叶子结点的链表中(即数据只能在叶子节点[也叫稠密索引)，且链表中的关键字(数据)恰好是有序的。 不可能在非叶子结点命中. 非叶子结点相当于是叶子结点的索引(稀疏索引)，叶子结点相当于是存储(关键字)数据的数据层 更适合文件索引系统 B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然. B*树B*树是B+树的变体，在B+树的非根和非叶子节点添加指向兄弟的指针 B树定义了非叶子结点关键字个数至少为(2/3)M， 即块的最低使用率为2/3， 而B+树的块的最低使用率为的1/2。 从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F06%2F22%2F08-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树为什么需要树 数组存储方式的分析 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。—-查询快缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动， 效率较低。—–增删慢 链式存储方式的分析 优点：在一定程度上对数组存储方式有优化(比如:插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)。—-增删快缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) —查询慢 树存储方式的分析 能提高数据存储，读取的效率，比如利用 二叉排序树(Binary Sort Tree),既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。—–兼顾增删和查询的速度 树的术语 节点：每一个“圆圈”—-&gt;每一个存储的对象 根节点：root节点—&gt;A 父节点：A节点是B和C节点的父节点 子节点：B和C节点是A节点的子节点 叶子节点(没有子节点的节点)：H、E、F、G 节点的权(节点值) 路径(从root节点找到该节点的路线) 层 子树 树的高度(最大层数) 森林:多颗子树构成森林 二叉树 二叉树：每个节点最多只能有两个子节点的一种形式称为二叉树。子节点分为左节点和右节点。 满二叉树：二叉树的所有叶子节点都在最后一层，并且节点总数=2^n-1，n为层数 完全二叉树：二又树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续 遍历（递归） 前序遍历：先输出父节点，再遍历左子树和右子树 中序遍历：先遍历左子树，再输出父节点，最后遍历右子树 后序遍历：先遍历左子树，再遍历右子树，最后输出父节点 总结：看父节点的输出顺序，确定是那种遍历 前序输出：1、2、3、5、4 中序输出：2、1、5、3、4 后序输出：2、5、4、3、1 应用实例： 节点类：HeroNode（主要是左节点和右节点属性） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 节点对象class HeroNode &#123; private int id; private String name; private HeroNode left; //左节点，默认为null private HeroNode right; //右节点，默认为null // 构造器 public HeroNode(int id, String name) &#123; this.id = id; this.name = name; &#125; // 省略set、get和toString方法 // 前序遍历:父节点---左子树---右子树 public void preOrder() &#123; // 父节点 System.out.println(this); // 左子树递归 if (this.left != null) &#123; this.left.preOrder(); &#125; // 右子树递归 if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; // 中序遍历:左子树---父节点---右子树 public void midOrder() &#123; // 左子树递归 if (this.left != null) &#123; this.left.midOrder(); &#125; // 父节点 System.out.println(this); // 右子树递归 if (this.right != null) &#123; this.right.midOrder(); &#125; &#125; // 后遍历:左子树---右子树---父节点 public void postOrder() &#123; // 左子树递归 if (this.left != null) &#123; this.left.postOrder(); &#125; // 右子树递归 if (this.right != null) &#123; this.right.postOrder(); &#125; // 父节点 System.out.println(this); &#125;&#125; 创建二叉树：BinaryTree（主要是根节点属性） 123456789101112131415161718192021222324252627282930313233class BinaryT&#123; private HeroNode root; public void setRoot(HeroNode root) &#123; this.root = root; &#125; // 前序遍历 public void preOrder() &#123; if (this.root != null) &#123; this.root.preOrder(); &#125; else &#123; System.out.println("二叉树为空..."); &#125; &#125; // 中序遍历 public void midOrder() &#123; if (this.root != null) &#123; this.root.midOrder(); &#125; else &#123; System.out.println("二叉树为空..."); &#125; &#125; // 后序遍历 public void postOrder() &#123; if (this.root != null) &#123; this.root.postOrder(); &#125; else &#123; System.out.println("二叉树为空..."); &#125; &#125;&#125; 查找（递归） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 前序查找 public HeroNode preSearch(int id) &#123; HeroNode resNode = null; // 1. 判断当前节点是否是要查找的节点 if (this.id == id) &#123; return this; &#125; // 2. 如果不是，则判断当前节点的左子节点是否为空，不为空则递归前序查找 if (this.left != null) &#123; resNode = this.left.preSearch(id); &#125; if (resNode != null) &#123; // 左子树前序递归找到 return resNode; &#125; // 3. 如果左子树递归没有找到，则判断右节点是否为空，不为空则递归前序查找 if (this.right != null) &#123; resNode = this.right.preSearch(id); &#125; return resNode; &#125; // 中序查找 public HeroNode midSearch(int id) &#123; HeroNode resNode = null; // 1. 判断当前节点的左子节点是否为空，不为空则递归前序查找 if (this.left != null) &#123; resNode = this.left.midSearch(id); &#125; if (resNode != null) &#123; // 左子树前序递归找到 return resNode; &#125; // 2. 没有找到则和当前节点比较，当前节点是否是要查找的节点 if (this.id == id) &#123; return this; &#125; // 3. 如果左子树递归没有找到，则判断右节点是否为空，不为空则递归前序查找 if (this.right != null) &#123; resNode = this.right.midSearch(id); &#125; return resNode; &#125; // 后序查找 public HeroNode postSearch(int id) &#123; HeroNode resNode = null; // 1. 判断当前节点的左子节点是否为空，不为空则递归前序查找 if (this.left != null) &#123; resNode = this.left.postSearch(id); &#125; if (resNode != null) &#123; // 左子树前序递归找到 return resNode; &#125; // 2. 如果左子树递归没有找到，则判断右节点是否为空，不为空则递归前序查找 if (this.right != null) &#123; resNode = this.right.postSearch(id); &#125; if (resNode != null) &#123; // 右子树前序递归找到 return resNode; &#125; // 3. 没有找到则和当前节点比较，当前节点是否是要查找的节点 if (this.id == id) &#123; return this; &#125; return resNode; &#125; 1234567891011121314151617181920212223242526272829// 前序查找 public HeroNode preSearch(int id) &#123; if (this.root == null) &#123; System.out.println("二叉树为空..."); return null; &#125; else &#123; return this.root.preSearch(id); &#125; &#125; // 中序查找 public HeroNode midSearch(int id) &#123; if (this.root == null) &#123; System.out.println("二叉树为空..."); return null; &#125; else &#123; return this.root.midSearch(id); &#125; &#125; // 后序查找 public HeroNode postSearch(int id) &#123; if (this.root == null) &#123; System.out.println("二叉树为空..."); return null; &#125; else &#123; return this.root.postSearch(id); &#125; &#125; 删除 如果删除的节点是叶子节点，则删除该节点 如果删除的节点是非叶子节点，则删除该子树. 由于二叉树是单向的，删除某个节点只能从他的父节点下手—–&gt;父节点.left=null或者父节点.right=null 123456789101112131415161718192021222324252627/** * 删除节点 * 1、如果删除的节点定叶子节点，则删除该节点 * 2、如果删除的节点是非叶子节点，则删除该子树 * @param id */ public void remove(int id)&#123; // 1. 如果当前节点的左子节点不为空且左子节点就是要删除的节点：this.left=null if (this.left!=null &amp;&amp; this.left.id==id)&#123; this.left=null; return; &#125; // 2. 如果当前节点的右子节点不为空且右子节点就是要删除的节点：this.right=null if (this.right!=null &amp;&amp; this.right.id==id)&#123; this.right=null; return; &#125; // 3. 左子树递归删除 if (this.left!=null)&#123; this.left.remove(id); &#125; // 4. 右子树递归删除 if (this.right!=null)&#123; this.right.remove(id); &#125; &#125; 12345678910111213// 删除节点 public void remove(int id)&#123; // 如果树是空树或者只有一个root节点 if (this.root == null) &#123; System.out.println("二叉树为空..."); return ; &#125; // 只有一个root节点 if (this.root.getLeft()==null &amp;&amp; this.root.getRight()==null)&#123; this.root=null; &#125; this.root.remove(id); &#125; 顺序存储二叉树参考 从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组。【在遍历数组时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历（与树遍历结果相同）】 顺序存储二叉树特点： 顺序二叉树通常只考虑完全二叉树 第n 个元素的左子节点编号为2*n+1 第n个元素的右子节点编号为2*n+2 第n个元素的父节点编号为(n-1)/2 n表示二叉树中的第几个元素（按0开始编号如图所示） 需求： 给你一个数组{1,2,3,4,5,6,7,8,9}， 要求以二叉树前序遍历的方式进行遍历 12345678910111213141516171819202122232425262728293031323334353637public class ArrayBinaryTreeDemo &#123; public static void main(String[] args) &#123; int[] array = &#123;16, 22, 3, 46, 15, 6, 7, 38, 9&#125;; ArrayBinaryTree arrayBinaryTree = new ArrayBinaryTree(array); arrayBinaryTree.preOrder(0); &#125;&#125;// 顺序存储二叉树class ArrayBinaryTree &#123; private int[] array; // 要转成顺序存储二叉树的数组 public ArrayBinaryTree(int[] array) &#123; this.array = array; &#125; /** * 前序遍历 * @param index 数组的下标 */ public void preOrder(int index) &#123; // 数组为空，则不遍历 if (array == null || array.length == 0) &#123; System.out.println("顺序存储二叉树为空...."); return; &#125; // 1. 输出当前元素 System.out.println(array[index]); // 2. 左子树遍历 if (2 * index + 1 &lt; array.length) &#123; preOrder(2 * index + 1); &#125; // 3. 右子树遍历 if (2 * index + 2 &lt; array.length) &#123; preOrder(2 * index + 2); &#125; &#125;&#125; 排序算法中的堆排序会用到顺序存储二叉树 线索二叉树参考 问题的提出： ​ 1. 当我们对上面的二叉树进行中序遍历时， 数列为{8, 3,10,1,14, 6} ​ 2. 但是6,8, 10,14这几个节点的左右指针，并没有完全的利用上`. ​ 3. 如果我们希望充分的利用 各个节点的左右指针，让各个节点可以指向自己的前后节点，怎么办? ​ 4. 解决方案-线索二叉树 线索二叉树基本介绍： n个结点的二叉链表中含有n+1 [2n-(n-1)=n+1] 个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针(这种附加的指针称为”线索”) 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。 根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 一个结点的前一个结点，称为前驱结点 一个结点的后一个结点，称为后继结点 应用案例： 说明: 当线索化二叉树后，Node节点的属性left 和right ，有如下情况: 1. left 指向的是左子树，也可能是指向的前驱节点。比如①节点left 指向的左子树，而0节点的left 指向的就是前驱节点. 2. right 指向的是右子树，也可能是指向后继节点。比如①节点right指向的是右子树，而0节点的right指向的是后继节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//先创建HeroNode 结点class HeroNode &#123; private int no; private String name; private HeroNode left; //默认null private HeroNode right; //默认null //说明 //1. 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点 //2. 如果rightType == 0 表示指向是右子树, 如果 1表示指向后继结点 private int leftType; private int rightType; public int getLeftType() &#123; return leftType; &#125; public void setLeftType(int leftType) &#123; this.leftType = leftType; &#125; public int getRightType() &#123; return rightType; &#125; public void setRightType(int rightType) &#123; this.rightType = rightType; &#125; public HeroNode(int no, String name) &#123; this.no = no; this.name = name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public HeroNode getLeft() &#123; return left; &#125; public void setLeft(HeroNode left) &#123; this.left = left; &#125; public HeroNode getRight() &#123; return right; &#125; public void setRight(HeroNode right) &#123; this.right = right; &#125; @Override public String toString() &#123; return "HeroNode [no=" + no + ", name=" + name + "]"; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//定义ThreadedBinaryTree 实现了线索化功能的二叉树class ThreadedBinaryTree &#123; private HeroNode root; //为了实现线索化，需要创建要给指向当前结点的前驱结点的指针 //在递归进行线索化时，pre 总是保留前一个结点 private HeroNode pre = null; public void setRoot(HeroNode root) &#123; this.root = root; &#125; //重载一把threadedNodes方法 public void threadedNodes() &#123; this.threadedNodes(root); &#125; //遍历线索化二叉树的方法 public void threadedList() &#123; //定义一个变量，存储当前遍历的结点，从root开始 HeroNode node = root; while(node != null) &#123; //循环的找到leftType == 1的结点，第一个找到就是8结点 //后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化 //处理后的有效结点 while(node.getLeftType() == 0) &#123; node = node.getLeft(); &#125; //打印当前这个结点 System.out.println(node); //如果当前结点的右指针指向的是后继结点,就一直输出 while(node.getRightType() == 1) &#123; //获取到当前结点的后继结点 node = node.getRight(); System.out.println(node); &#125; //替换这个遍历的结点 node = node.getRight(); &#125; &#125; //编写对二叉树进行中序线索化的方法 /** * * @param node 就是当前需要线索化的结点 */ public void threadedNodes(HeroNode node) &#123; //如果node==null, 不能线索化 if(node == null) &#123; return; &#125; //(一)先线索化左子树 threadedNodes(node.getLeft()); //(二)线索化当前结点[有难度] //处理当前结点的前驱结点 //以8结点来理解 //8结点的.left = null , 8结点的.leftType = 1 if(node.getLeft() == null) &#123; //让当前结点的左指针指向前驱结点 node.setLeft(pre); //修改当前结点的左指针的类型,指向前驱结点 node.setLeftType(1); &#125; //处理后继结点 if (pre != null &amp;&amp; pre.getRight() == null) &#123; //让前驱结点的右指针指向当前结点 pre.setRight(node); //修改前驱结点的右指针类型 pre.setRightType(1); &#125; //!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点 pre = node; //(三)在线索化右子树 threadedNodes(node.getRight()); &#125;结： 总结： 二叉树的遍历本质上是将一个复杂的非线性结构转换为线性结构，使每个结点都有了唯一前驱和后继（第一个结点无前驱，最后一个结点无后继）。对于二叉树的一个结点，查找其左右子女是方便的，其前驱后继只有在遍历中得到。为了容易找到前驱和后继，有两种方法。一是在结点结构中增加向前和向后的指针，这种方法增加了存储开销，不可取；二是利用二叉树的空链指针。 线索二叉树的优势：a. 利用线索二叉树进行中序遍历时，不必采用堆栈处理，速度较一般二叉树的遍历速度快，且节约存储空间；b. 任意一个结点都能直接找到它的前驱和后继结点 线索二叉树的不足：a. 结点的插入和删除麻烦，且速度也较慢；b. 线索子树不能共用]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F06%2F22%2F07-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[哈希表基本介绍 哈希表（hash table），又叫散列表，是根据关键码值（Key value）而直接进行访问的数据结构。即通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 哈希表可以存储各种类型的数据，当我们从哈希表中查找所需要的数据时，理想情况是不经过任何比较，一次存取便能得到所查记录，那就必须在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使每个关键字和结构中一个唯一的存储位置相对应。(关键字就是所要存储的数据，存储位置相当于数组的索引) 示意图（数组+链表）： 数组+链表实现有一个公司，当有新的员工来报道时，要求将该员工的信息加入(id,性别，年龄，名字，住址.)，当输入该员工的id时，要求查找到该员工的所有信息 要求： 不使用数据库，速度越快越好====&gt;哈希表(散列) 添加时，保证按照id从低到高插入（课后思考：如果id不是从低到高插入，但要求各条链表仍是从低到高，怎么解决?） 使用链表来实现哈希表，该链表不带表头（即:链表的第-个结点就存放雇员信息） 思路分析并画出示意图 代码实现： 员工类：代表链表中存放的数据类型 1234567891011121314151617class Emp &#123; public int id; public String name; public Emp next; //指向下一个对象的域，默认为null // 构造器 public Emp(int id, String name) &#123; this.id = id; this.name = name; &#125; @Override public String toString() &#123; return "Emp&#123;" + "id=" + id + ", name='" + name + '\'' + '&#125;'; &#125;&#125; 链表：管理存入的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class EmpLinkedList &#123; Emp head = null; // 头结点 /** * 添加到链表的末尾: id从低到高 * @param emp */ public void add(Emp emp) &#123; // 添加第一个 if (head == null) &#123; head = emp; return; &#125; // 不是第一个，则先找到链表末尾，添加到后面 Emp curEmp = head; while (true) &#123; if (curEmp.next == null) &#123; break; &#125; curEmp = curEmp.next; // 后移 &#125; // 找到末尾后添加 curEmp.next = emp; &#125; /** * 遍历某条链表的雇员信息并显示 * @param no */ public void show(int no) &#123; // 链表为空则结束 if (head == null) &#123; System.out.println("第" + (no + 1) + "条链表为空..."); return; &#125; // 遍历链表的雇员信息并显示 Emp curEmp = head; while (true) &#123; System.out.println("第" + (no + 1) + "条链表的信息为=&gt;id=" + curEmp.id + ", name=" + curEmp.name); if (curEmp.next == null) &#123; break; &#125; curEmp = curEmp.next; // 指针后移 &#125; &#125; /** * 根据id查找 * @param id * @return */ public Emp findById(int id) &#123; if (head == null) &#123; System.out.println("链表为空..."); return null; &#125; Emp curEmp = head; while (true) &#123; if (curEmp.id == id) &#123; //找到退出 break; &#125; if (curEmp.next == null) &#123; //遍历完也没找到退出 curEmp = null; break; &#125; curEmp = curEmp.next; //索引指针后移 &#125; return curEmp; &#125;&#125; 数组：管理链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class HashTab &#123; private EmpLinkedList[] empLinkedListArray; // 管理链表的数组 private int size; // 管理的链表的条数 // 构造器 public HashTab(int size) &#123; this.size = size; // 初始化empLinkedListArray empLinkedListArray = new EmpLinkedList[size]; // !!!初始化每条链表 for (int i = 0; i &lt; size; i++) &#123; empLinkedListArray[i] = new EmpLinkedList(); &#125; &#125; /** * 添加操作 * @param emp */ public void add(Emp emp) &#123; // 根据id（索引）判断应该添加到哪条链表===&gt; 散列函数 int no = hashMapper(emp.id); // 待添加位置的索引 // 添加到对应的链表中去 empLinkedListArray[no].add(emp); &#125; /** * 遍历所有链表 */ public void list() &#123; for (int i = 0; i &lt; size; i++) &#123; empLinkedListArray[i].show(i); &#125; &#125; /** * 根据id查找员工 * @param id */ public void findById(int id)&#123; // 确定当前id在哪条链表 int no = hashMapper(id); Emp resEmp = empLinkedListArray[no].findById(id); if (resEmp==null)&#123; System.out.println("没有找到该员工..."); &#125;else &#123; System.out.println("在"+(no+1)+"条链表中找到员工\n"+"员工信息："+resEmp); &#125; &#125; /** * 散列函数 * @param id * @return 哈希值 */ public int hashMapper(int id) &#123; return id % size; &#125;&#125; 哈希冲突HashMap的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F06%2F22%2F06-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[查找算法线性查找线性查找就是逐一对比来查找元素 有一个数列: {1,8, 10, 89, 1000, 1234}，判断数列中是否包含此名称[顺序查找]要求:如果找到了，就提示找到，并给出下标值。 12345678910111213141516171819202122232425262728293031public class SeqSearch &#123; public static void main(String[] args) &#123; int[] array1 = &#123;1, 8, 10, 89, 1000, 1234&#125;; int[] array2 = &#123;1, 8, 10, 8, 8, 89, 1000, 1234&#125;; int resIndex = searchOne(array1, 7); System.out.println(resIndex); List list = searchAll(array2, 8); System.out.println(list); &#125; // 找到第一个匹配的就退出 public static int searchOne(int[] array, int findValue) &#123; // 线性查找就是逐一比对 for (int i = 0; i &lt; array.length; i++) &#123; if (findValue == array[i]) &#123; return i; &#125; &#125; return -1; &#125; // 匹配所有的下标 public static List searchAll(int[] array, int findValue) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // 线性查找就是逐一比对 for (int i = 0; i &lt; array.length; i++) &#123; if (findValue == array[i]) &#123; list.add(i); &#125; &#125; return list; &#125;&#125; 二分查找 基本思想： 在有序序列中查找，将有序序列一分为二，对半递归查找 示意图： 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class BinarySearch &#123; public static void main(String[] args) &#123; int[] array1 = &#123;1, 8, 10, 89, 1000, 1234&#125;; int[] array2 = &#123;1, 8, 10, 8, 8, 89, 1000, 1234, 8&#125;; int i = searchOne(array1, 0, array1.length - 1, 8); System.out.println(i); List&lt;Integer&gt; list = searchAll(array2, 0, array2.length - 1, 8); System.out.println(list); &#125; /** * 查找到一个匹配的后就退出 * @param array * @param left 待查找数组的最左边索引 * @param right 待查找数组的最右边索引 * @param findValue * @return */ public static int searchOne(int[] array, int left, int right, int findValue) &#123; int mid = (left + right) / 2; // 中间索引 int midValue = array[mid]; // 退出查找条件: // 1. 查找完所有，没有匹配：left&gt;right // 2. 待查找元素越界：findValue&lt;array[left] || findValue&gt;array[right] if (left &gt; right || findValue &lt; array[left] || findValue &gt; array[right]) &#123; return -1; &#125; // findValue&gt;midValue则在右边递归查找 // findValue&lt;midValue则在左边递归查找 // findValue=midValue则返回mid if (findValue &gt; midValue) &#123; return searchOne(array, mid + 1, right, findValue); &#125; else if (findValue &lt; midValue) &#123; return searchOne(array, left, mid - 1, findValue); &#125; else &#123; return mid; &#125; &#125; public static List&lt;Integer&gt; searchAll(int[] array, int left, int right, int findValue) &#123; int mid = (left + right) / 2; // 中间索引 int midValue = array[mid]; if (left &gt; right || findValue &lt; array[left] || findValue &gt; array[right]) &#123; return new ArrayList&lt;Integer&gt;(); &#125; if (findValue &gt; midValue) &#123; return searchAll(array, mid + 1, right, findValue); &#125; else if (findValue &lt; midValue) &#123; return searchAll(array, left, mid - 1, findValue); &#125; else &#123; // 1. 找到mid后，不要马上返回 // 2. 向mid索引值左边扫描，将所有匹配的下标添加到list // 3. 向mid索引值右边扫描，将所有匹配的下标添加到list List resList = new ArrayList&lt;Integer&gt;(); // 将匹配到的第一个下标添加到list resList.add(mid); // 向左扫描 int tempIndex = mid - 1; while (tempIndex &gt; 0) &#123; if (findValue == array[tempIndex]) &#123; resList.add(tempIndex); &#125; tempIndex--; &#125; // 向右扫描 tempIndex = mid + 1; while (tempIndex &lt; array.length) &#123; if (findValue == array[tempIndex]) &#123; resList.add(tempIndex); &#125; tempIndex++; &#125; return resList; &#125; &#125;&#125; 插值查找插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。 1int mid = left+(findValue-array[left])/(array[right]-array[left])(right-left); 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快 关键字分布不均匀的情况下，该方法不一定比折半查找要好]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F06%2F22%2F05-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法十大排序算法介绍 冒泡排序 基本思想： 通过对待排序序列从前向后(从下标较小的元素开始)，依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。 优化: 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换,就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。 示意图： 一共进行 数组大小-1 趟过程，每一趟都找到一个最大的数放在最后 每一趟比较的次数在逐渐减小 如果我们发现在某趟排序中，没有发生一次交换，可以提前结束冒泡排序（优化） 代码实现 1234567891011121314151617181920212223242526272829303132333435public class BubbleSort &#123; public static void main(String[] args) &#123; int[] array = &#123;3, 0, -3, -1, 10, 7&#125;; sort(array); System.out.println(Arrays.toString(array)); &#125; public static void sort(int[] array) &#123; int temp = 0; // 临时变量，交换数据位置用 boolean flag = false; // 标识变量，每一趟是有逆序，进行了位置交换 // 1. 总共需要 array.length-1 趟比较 // 2. 每一趟依次需要比较 array.length-1，array.length-1-1，array.length-1-2，.... 次 for (int i = 0; i &lt; array.length - 1; i++) &#123; for (int j = 0; j &lt; array.length - 1 - i; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; // flag置为true flag = true; // 逆序则交换位置 temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; // 这一趟没有发生数据交换 if (!flag) &#123; break; &#125; else &#123; flag = false; // !!! 重置flag，进行下一次判断 &#125; &#125; &#125;&#125; 时间复杂度：O(n^2) 选择排序 基本思想： 选择排序(select sorting)也是一种简单的排序方法。它的基本思想是：第一次从arr[0]~arr[n-I]中选取最小值，与rr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从rr[2]ar[n-1]中选取最小值，与arr[2]交换，.，第i次从ar[i-1]~arr[n-1]中选取最小值，与arr[-1]交换，..第n-1次从ar[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。 示意图： 一共进行 数组大小-1 轮排序 每一轮都找到一个最小的数放在当前待排序数组的最前面 代码实现 12345678910111213141516171819202122232425262728public class SelectSort &#123; public static void main(String[] args) &#123; int[] array = &#123;20, -2, 6, 30, -5, 1&#125;; sort(array); System.out.println(Arrays.toString(array)); &#125; public static void sort(int[] array) &#123; // 1. 共进行array.length-1 轮排序 for (int i = 0; i &lt; array.length - 1; i++) &#123; // 假定最小值为待排序数组的第一个值 int minIndex = i; // 最小值的索引 // 2. 每一轮比较 array.length-1-i次 for (int j = i + 1; j &lt; array.length; j++) &#123; // 找到最小的数对应的索引 if (array[minIndex] &gt; array[j]) &#123; minIndex = j; &#125; &#125; // 交换位置:array[i]&lt;---&gt;array[minIndex] if (minIndex != i) &#123; int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125; &#125; &#125;&#125; 插入排序 基本思想： 把n个待排序的元素看成为一个有序表和-一个无序表，开始时有序表中只包含一一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 原理类似打扑克牌时将手上的牌按顺序码好 示意图： 将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面）- 代码实现 123456789101112131415161718192021222324public class InsertSort &#123; public static void main(String[] args) &#123; int[] array=&#123;20,-1,3,2,30,-4&#125;; sort(array); System.out.println(Arrays.toString(array)); &#125; public static void sort(int[] array)&#123; for (int i = 1; i &lt;array.length ; i++) &#123; // &#123;20,-1,3,2,30,-4&#125; ---&gt; &#123;-1,20,3,2,30,-4&#125; ---&gt; &#123;-1,3,20,2,30,-4&#125; int insertValue=array[i]; // 待插入的数 int insertIndex=i-1; // 待插入的数的前一个数 // 在有序列表中找到自己的位置 // 1. insertIndex&gt;=0保证不越界 // 2. array[insertIndex]&gt; insertValue说明还没有找到自己的位置 // 3. 需要将array[insertIndex]后移 while (insertIndex&gt;=0 &amp;&amp; array[insertIndex]&gt; insertValue)&#123; array[insertIndex+1]=array[insertIndex]; insertIndex--; &#125; // 找到位置：insertIndex+1 ，插入进去 array[insertIndex+1]=insertValue; &#125; &#125;&#125; 希尔排序 基本思想： 简单的插入排序可能存在的问题：数组arr= {2,3,4,5,6,1}这时需要插入的数1(最小), 这样的过程是:{2,3,4.5,6.6} {2,3,4,5,5,6} {2,3,4,4,5,6} {2,3,3,4,5,6} {2,2,3,4,5,6} {1,2,3,4,5,6} 结论：当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响. 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 示意图： 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ShellSort &#123; public static void main(String[] args) &#123; int[] array = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;; sort(array); System.out.println(Arrays.toString(array)); &#125; public static void sort(int[] array) &#123; // 推导 // &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125; // 第一次整合 /* for (int i = 5; i &lt; array.length; i++) &#123; int j = i; int temp = array[j]; // 待插入的元素array[5] if (array[j] &lt; array[j - 5]) &#123; // array[5]&lt;array[0] // 移动找位置 while (j - 5 &gt;= 0 &amp;&amp; temp &lt; array[j - 5]) &#123; array[j] = array[j - 5]; j -= 5; &#125; // 退出while循环后找到了位置，将要插入的元素插入到此位置 array[j] = temp; &#125; &#125; System.out.println("第一次排序后：" + Arrays.toString(array));*/ // 增量gap，并逐步缩小增量 for (int gap = array.length / 2; gap &gt; 0; gap /= 2) &#123; // 依次对每个分组进行直接插入排序 for (int i = gap; i &lt; array.length; i++) &#123; int j = i; int temp = array[j]; // 待插入的元素array[5] if (array[j] &lt; array[j - gap]) &#123; // array[5]&lt;array[0] // 移动找位置 while (j - gap &gt;= 0 &amp;&amp; temp &lt; array[j - gap]) &#123; array[j] = array[j - gap]; j -= gap; &#125; // 退出while循环后找到了位置，将要插入的元素插入到此位置 array[j] = temp; &#125; &#125; &#125; &#125;&#125; 快速排序 基本思想： 在数组中选一个基准数（通常为数组第一个）； 将数组中小于基准数的数据移到基准数左边，大于基准数的移到右边； 对于基准数左、右两边的数组，不断重复以上两个过程，直到每个子集只有一个元素，即为全部有序 示意图： 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.arnold.sort;import java.util.Arrays;public class QuickSort &#123; public static void main(String[] args) &#123; int[] array = &#123;-9, 78, 0, 23, -567, 70&#125;; sort(array, 0, array.length - 1); System.out.println(Arrays.toString(array)); &#125; /** * @param array 待排序数组 * @param left 区间的最左边 * @param right 区间的最右边 */ public static void sort(int[] array, int left, int right) &#123; //如果区间不只一个数 if (left &lt; right) &#123; int pivot = array[left]; // 将区间的第一个数作为基准 int i = left; // 从左往右进行查找的索引，指向当前区间的最左边 int j = right; // 从右往左进行查找的索引，指向当前区间的最右边 // 遍历对区间按照基准排序 while (i &lt; j) &#123; // (一)、从右向左查找 // 当右边的数大于基准数时，略过，继续向左查找：array[j]&gt;pivot while (i &lt; j &amp;&amp; array[j] &gt; pivot) &#123; j--; &#125; // 跳出循环时，此时的j对应的元素是小于基准元素的，将j对应的元素填充到此时i对应的位置 array[i] = array[j]; // (二)、从左向右查找 // 当左边的数小于基准数时，略过，继续向右查找：array[i]&lt;pivot while (i &lt; j &amp;&amp; array[i] &lt; pivot) &#123; i++; &#125; // 跳出循环时，此时的i对应的元素是大于基准元素的，将i对应的元素填充到此时j对应的位置 array[j] = array[i]; &#125; // 跳出循环时：i=j，此时再将基准元素插入到i和j重合的位置上 array[i] = pivot; // 对基准左边元素递归分区排序 sort(array, left, right - 1); // 对基准右边元素递归分区排序 sort(array, left + 1, right); &#125; else &#123; return; &#125; &#125;&#125; 在java.util.Arrays.sort中，基本类型数组排序所使用的算法就是归并算法 归并排序 基本思想： 将n个元素从中间切开，分成两部分。（左边可能比右边多1个数） 将步骤1分成的两部分，再分别进行递归分解。直到所有部分的元素个数都为1。 从最底层开始逐步合并两个排好序的数列。 示意图： 如何归并：如何将两个有序数列合并成一个有序数列？ 由于两个数列都已经有序，我们只需从两个数列的低位轮番拿出各自最小的数来PK就就行了，输的一方为小值，将这个值放入临时数列，然后输的一方继续拿出一个值来PK，直至有一方没有元素后，将另一方的所有元素依次接在临时数列后面即可。此时，临时数列为两个数列的有序合并 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MergeSort &#123; public static void main(String[] args) &#123; int[] array = &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;; int[] temp = new int[array.length]; sort(array, 0, array.length - 1, temp); System.out.println(Arrays.toString(array)); &#125; public static void sort(int[] array, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; // 向左递归分解 sort(array, left, mid, temp); // 向右递归分解 sort(array, mid + 1, right, temp); // 合并有序序列 merge(array, left, right, mid, temp); &#125; &#125; /** * 合并的方法 * @param array 待合并数组 * @param left 左边有序序列的初始索引 * @param right 右边有序序列的初始索引 * @param mid 左边和右边的中间索引 * @param temp 中转数组 */ public static void merge(int[] array, int left, int right, int mid, int[] temp) &#123; int i = left; // 第一组的起点i int j = mid + 1; // 第二组的起点j，mid=(left+right)/2 int t = 0; // 中转数组的索引t // (一)、把左右两边的有序序列按照规则填充到temp数组 // 直到左右两边的序列有一个序列处理完毕 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; // 如果左边元素小于对应右边元素，则将左边元素填充到temp数组 if (array[i] &lt;= array[j]) &#123; temp[t] = array[i]; t++; i++; &#125; else &#123; temp[t] = array[j]; t++; j++; &#125; &#125; // (二)、把有剩余序列的剩余元素依次填充到temp数组 // 左边有剩余 while (i &lt;= mid) &#123; temp[t] = array[i]; t++; i++; &#125; // 右边有剩余 while (j &lt;= right) &#123; temp[t] = array[j]; t++; j++; &#125; // (三)、把temp数组拷贝到array（并不是每次都拷贝所有） for (i = 0; i &lt; t; i++) &#123;// 将排好序的数填回到array数组的对应位置 array[left + i] = temp[i]; &#125; &#125;&#125; 在java.util.Arrays.sort中，对象数组排序所使用的算法就是归并算法 基数排序1)、 基数排序(radixsort) 属于“分配式排序”(distributionsort) ，又称“桶子法”(bucket sort) 或binsort， 顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用 2)、基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法 3)、基数排序(Radix Sort)是桶排序的扩展 基本思想： 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。 这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。 示意图： 代码实现： 获取最大数的位数： int maxLength = (max + &quot;&quot;).length(); 取出个位数（n=1）、十位数（n=10）、….：int digitValue = value / n % 10； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class RadixSort &#123; public static void main(String[] args) &#123; int[] array = &#123;53, 3, 542, 748, 14, 214&#125;; sort(array); System.out.println(Arrays.toString(array)); &#125; public static void sort(int[] array) &#123; // 获取当前数组的最大数 int max = array[0]; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; // 获取最大数的位数 int maxLength = (max + "").length(); for (int i = 0, n = 1; i &lt; maxLength; i++, n *= 10) &#123; // 定义一个二维数组：表示10个桶，每个桶里有一个一位数组存放该桶的元素 // 每个桶里有一个一位数组的长度不确定，最坏情况下为数组的长度（都排在了一个桶里） int[][] bucket = new int[10][array.length]; // 定义一个一位数组：表示每个桶存放的元素的个数 // 示例：bucketElementsCounts[0]表示bucket[0]桶里存放的数据的个数 int[] bucketElementsCounts = new int[10]; // 对每个元素的个位进行排序 for (int j = 0; j &lt; array.length; j++) &#123; // 取出个位数 int digitOfElements = array[j] / n % 10; // 53%10=3; 542/100%10=5 // 放入到对应的桶中 bucket[digitOfElements][bucketElementsCounts[digitOfElements]] = array[j]; bucketElementsCounts[digitOfElements]++; &#125; // 将每个桶里的元素依次取出放入到array数组中 int index = 0; for (int k = 0; k &lt; 10; k++) &#123; // 如果桶里有元素就取出 if (bucketElementsCounts[k] != 0) &#123; for (int l = 0; l &lt; bucketElementsCounts[k]; l++) &#123; array[index++] = bucket[k][l]; &#125; &#125; &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F06%2F22%2F04-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归递归的概念 简单的说：递归就是方法自己调用自己，每次调用时传入不同的变量；递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。 递归调用机制案例递归调用规则： 当程序执行到一个方法时，就会开辟一个独立的空间（栈空间） 每个栈空间的数据（局部变量）是独立的 案例： 打印问题 123456789101112public class RecursiveIllustration &#123; public static void main(String[] args) &#123; test(4); &#125; // 1.打印问题 public static void test(int n) &#123; if (n &gt; 2) &#123; test(n - 1); &#125; System.out.println("n=" + n); &#125;&#125; 阶乘问题 12345678// 2.阶乘问题 public static int factorial(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return factorial(n - 1) * n; &#125; &#125; 递归能解决的问题 各种数学问题如:8皇后问题，汉诺塔，阶乘问题,迷宫问题，球和篮子的问题(google编程大赛) 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等. 将用栈解决的问题–&gt;递归代码比较简洁 递归需要遵守的重要规则 执行一个方法时，就创建一个新的受保护的独立空间(栈空间) 方法的局部变量是独立的，不会相互影响，比如n变量 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据. 递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOvrflowError，死归了:) 当一个方法执行完毕，或者遇到return, 就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕 递归—迷宫问题 问题描述：小球从某一点出发，找到能到达右下角位置的通路 思路： 创建迷宫—二维数组、1表示这个点是障碍物 约定小球运动策略：上—&gt;右—&gt;下—&gt;左 约定当某点 为 0 表示该点没有走过 ，当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package cn.arnold.recursive;// 迷宫问题public class Maze &#123; public static void main(String[] args) &#123; // 创建迷宫 int[][] map = new int[8][7]; // 设置障碍物 for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; // 左右全部置为1 for (int i = 0; i &lt; 8; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; map[3][1] = 1; map[3][2] = 1; // 输出迷宫 for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + " "); &#125; System.out.println(); &#125; findWay(map, 1, 1); System.out.println("走过后的迷宫"); // 输出迷宫 for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + " "); &#125; System.out.println(); &#125; &#125; /** * 按照上---&gt;右---&gt;下---&gt;左 策略找通路 * * @param map 地图 * @param i 起始点坐标 * @param j * @return */ // 当某点 为 0 表示该点没有走过 ，当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通 public static boolean findWay(int[][] map, int i, int j) &#123; if (map[6][5] == 2) &#123; // 2 表示通路可以走 return true; &#125; else &#123; if (map[i][j] == 0) &#123; // 为 0 表示该点没有走过 map[i][j] = 2; // 假定该点可以走通 if (findWay(map, i + 1, j)) &#123; // 向下走 return true; &#125; else if (findWay(map, i, j + 1)) &#123; // 向右走 return true; &#125; else if (findWay(map, i - 1, j)) &#123; // 向下走 return true; &#125; else if (findWay(map, i, j - 1)) &#123; // 向左走 return true; &#125; else &#123; map[i][j] = 3; // 3 表示该点已经走过，但是走不通 return false; &#125; &#125; else &#123; return false; &#125; &#125; &#125;&#125; 八皇后问题 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯.贝瑟尔于1848年提出：在8X8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同-一列或同一斜线上，问有多少种摆法(92)。 思路 第一个皇后先放第一行第一列 第二个皇后放在第二行第一列、 然后判断是否OK，如果不OK， 继续放在第二列、第三列、依次把所有列都放完，找到一个合适 继续第三个皇后，还是第一-列、第二列….直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到. 然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤 示意图: 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8]={0,4, 7,5, 2, 6, 1, 3} //对应arr下标表示第几行，即第几个皇后，arr[i]=val,val 表示第计1个皇后，放在第i+1行的第val+1列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Queen8 &#123; // 有多少个皇后 int max=8; // 定义一个数组，保存皇后放置位置的结果,比如 arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125; int[] array=new int[max]; // 解的个数 static int count = 0; // 判断是否冲突的次数 static int judgeCount = 0; public static void main(String[] args) &#123; //测试一把 ， 8皇后是否正确 Queen8 queue8 = new Queen8(); queue8.check(0); System.out.printf("一共有%d解法", count); System.out.println(); System.out.printf("一共判断冲突的次数%d次", judgeCount); // 1.5w &#125; /** * 递归寻找解 * @param n */ //特别注意： check 是 每一次递归时，进入到check中都有 for(int i = 0; i &lt; max; i++)，因此会有回溯 private void check(int n) &#123; if(n == max) &#123; //n = 8 , 其实8个皇后就既然放好 print(); return; &#125; //依次放入皇后，并判断是否冲突 for(int i = 0; i &lt; max; i++) &#123; //先把当前这个皇后 n , 放到该行的第1列 array[n] = i; //判断当放置第n个皇后到i列时，是否冲突 if(judge(n)) &#123; // 不冲突 //接着放n+1个皇后,即开始递归 check(n+1); // &#125; //如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置 &#125; &#125; /** * 判断第n和n-1个皇后是否冲突 * @param n 第几个皇后 * @return */ public boolean judge(int n)&#123; judgeCount++; for (int i = 0; i &lt;n ; i++) &#123; //1. array[i] == array[n] 表示判断 第n个皇后是否和前面的n-1个皇后在同一列 //2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线 //3. 判断是否在同一行, 没有必要，n 每次都在递增 if (array[i]==array[n] || Math.abs(n-i)==Math.abs(array[n]-array[i]))&#123; return false; &#125; &#125; return true; &#125; //写一个方法，可以将皇后摆放的位置输出 private void print() &#123; count++; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + " "); &#125; System.out.println(); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F06%2F22%2F03-%E6%A0%88%EF%BC%88Stack%EF%BC%89%2F</url>
    <content type="text"><![CDATA[栈（Stack）介绍 栈的英文为（stack） 栈是一个先入后出（FILO-First In Last Out）的有序列表。 栈（stack）是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶（Top），另一端为固定的一端，称为栈底（Bottom）。 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除 图解方式说明出栈（pop）和入栈（push）的概念 栈的应用场景 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。 表达式的转换[中缀表达式转后缀表达式]与求值（实际解决）。 二叉树的遍历。 图形的深度优先（depth-first）搜索法。 栈的快速入门 用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，下面我们就用数组模拟栈的出栈，入栈等操作。 实现思路分析，并画出示意图 定义一个top表示栈顶，初始化为-1 入栈：当有数据加入时 top++ stack[top]=value 出栈 value=stack[top] top– 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package cn.arnold.stack;public class Stack &#123; private int maxSize; //数组（栈）的大小 private int[] arrayStack; //数组模拟栈 private int top = -1; //栈顶指针，初始化为-1 // 构造器 public Stack(int maxSize) &#123; this.maxSize = maxSize; arrayStack = new int[this.maxSize]; // 初始化数组 &#125; // 栈满 public boolean isFull() &#123; return top == maxSize - 1; &#125; // 栈空 public boolean isEmpty() &#123; return top == -1; &#125; // 入栈 public void push(int value) &#123; if (isFull()) &#123; System.out.println("栈满..."); return; &#125; top++; arrayStack[top] = value; &#125; // 出栈 public int pop() &#123; int res = 0; if (isEmpty()) &#123; throw new RuntimeException("栈空..."); &#125; res = arrayStack[top]; top--; return res; &#125; // 遍历 public void showStack() &#123; if (isEmpty()) &#123; System.out.println("栈空..."); return; &#125; // 从栈顶开始显示数据 for (int i = top; i &gt;= 0; i--) &#123; System.out.println("arrayStack[" + i + "]=" + arrayStack[i]); &#125; &#125;&#125; 中缀表达式转后缀表达式 中缀表达式：8+(7-3)*2+8 后缀表达式（逆波兰表达式）：8 7 3 - 2 + 8 * + 中缀表达式符合人们的习惯，但计算机底层不容易处理；后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将中缀表达式转成后缀表达式 具体步骤如下： 初始化两个栈：运算符栈s1和储存中间结果的栈s2； 从左至右扫描中缀表达式； 遇到操作数时，将其压s2； 遇到运算符时，比较其与s1栈顶运算符的优先级：1.如果s1为空，或栈顶运算符为左括号”(“，则直接将此运算符入栈；2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到（2.1）与s1中新的栈顶运算符相比较； 遇到括号时： 1.如果是左括号”(“，则直接压入s1 2.如果是右括号”)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 重复步骤1至3，直到表达式的最右边 将s1中剩余的运算符依次弹出并压入s2； 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式。 将中缀表达式转为List： 12345678910111213141516171819202122232425262728293031323334353637public List&lt;String&gt; infixExptoList(String infix) &#123; // 存放中缀表达式转化后的值 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int index = 0; //遍历指针 char c; //每次遍历到的字符 String str; //用于拼接多位数 /*do &#123; // c是非数字则直接加入到list if ((c = infix.charAt(index)) &lt; 48 || (c = infix.charAt(index)) &gt; 57) &#123; list.add("" + c); // char转为String index++; &#125; else &#123; // c是数字则要考虑多位数 str = ""; while (index &lt; infix.length() &amp;&amp; (c = infix.charAt(index)) &gt;= 48 &amp;&amp; (c = infix.charAt(index)) &lt;= 57) &#123; str += c; //拼接 index++; &#125; list.add(str); &#125; &#125; while (index &lt; infix.length());*/ for (int i = 0; i &lt; infix.length(); i++) &#123; c = infix.charAt(i); // c是非数字则直接加入到list if (c &lt; 48 || c &gt; 57) &#123; list.add("" + c); &#125; else &#123; // c是数字则要考虑多位数 str = ""; while (i &lt; infix.length() &amp;&amp; (c = infix.charAt(i)) &gt;= 48 &amp;&amp; (c = infix.charAt(i)) &lt;= 57) &#123; str += c; //拼接 i++; &#125; list.add(str); &#125; &#125; return list; &#125; 中缀转后缀 123456789101112131415161718192021222324252627282930313233343536373839404142//即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–] //方法：将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List public static List&lt;String&gt; parseSuffixExpreesionList(List&lt;String&gt; ls) &#123; //定义两个栈 Stack&lt;String&gt; s1 = new Stack&lt;String&gt;(); // 符号栈 //说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出 //因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2 //Stack&lt;String&gt; s2 = new Stack&lt;String&gt;(); // 储存中间结果的栈s2 List&lt;String&gt; s2 = new ArrayList&lt;String&gt;(); // 储存中间结果的Lists2 //遍历ls for(String item: ls) &#123; //如果是一个数，加入s2 if(item.matches("\\d+")) &#123; s2.add(item); &#125; else if (item.equals("(")) &#123; s1.push(item); &#125; else if (item.equals(")")) &#123; //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 while(!s1.peek().equals("(")) &#123; s2.add(s1.pop()); &#125; s1.pop();//!!! 将 ( 弹出 s1栈， 消除小括号 &#125; else &#123; //当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较 //问题：我们缺少一个比较优先级高低的方法 while(s1.size() != 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item) ) &#123; s2.add(s1.pop()); &#125; //还需要将item压入栈 s1.push(item); &#125; &#125; //将s1中剩余的运算符依次弹出并加入s2 while(s1.size() != 0) &#123; s2.add(s1.pop()); &#125; return s2; //注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List &#125; 逆波兰计算器]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F06%2F22%2F02-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表（linklisted）介绍 链表是有序列表，但是在内存中的存储不是连续的，如下图： 链表是以节点的方式来存储，是链式存储 每个节点包含data域，next域：指向下一个节点. 如图：发现链表的各个节点不一定是连续存储. 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定 单链表使用带head头的单链表—水浒传英雄榜的增删改查 方法一：直接添加到链表的尾部（不排序—按添加的顺序） 方法二：根据排名将英雄插入到指定位置（如果有这个排名，则添加失败，并给出提示） 实现： 12345678910111213// 英雄节点类，每一个英雄就是一个节点public class HeroNode &#123; private int num; private String name; private String nickname; private HeroNode next; // 指向下一个节点 // 构造器 public HeroNode(int num, String name, String nickname) &#123; this.num = num; this.name = name; this.nickname = nickname; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// 单链表类public class SingleLinkedList &#123; // 头结点 private HeroNode headNode = new HeroNode(0, "", ""); // 1.添加节点到链表尾部:next为null public void addNode(HeroNode heroNode) &#123; // 临时变量 HeroNode temp = headNode; // 遍历：找到尾部元素 // 结束条件：temp.next==null while (true) &#123; if (temp.getNext() == null) &#123; break; &#125; // 没有找到，则temp后移 temp = temp.getNext(); &#125; // 添加节点 temp.setNext(heroNode); &#125; // 2.按编号顺序添加到链表尾部 public void addNodeByOrder(HeroNode heroNode) &#123; // 找到要插入节点的前一个位置插入 // 临时变量 HeroNode temp = headNode; boolean flag = false; // 是否已经存在要插入的编号 while (true) &#123; if (temp.getNext() == null) &#123; break; &#125; if (temp.getNext().getNum() &gt; heroNode.getNum()) &#123; // 找到要插入的位置 break; &#125; else if (temp.getNext().getNum() == heroNode.getNum()) &#123; //已经存在要插入的编号 System.out.println("表中已存在该元素"); flag = true; break; &#125; // temp后移 temp = temp.getNext(); &#125; // 添加节点 if (flag) &#123; System.out.printf("准备添加的英雄编号%d已经存在了，不能添加", heroNode.getNum()); &#125; else &#123; heroNode.setNext(temp); temp.setNext(heroNode); &#125; &#125; // 3.修改节点 public void update(HeroNode heroNode)&#123; // 判断是否为空 if (headNode.getNext() == null) &#123; System.out.println("链表为空"); return; &#125; // 找到要修改的节点：根据编号 HeroNode temp = headNode.getNext(); boolean flag = false; while (true)&#123; if (temp == null)&#123; break; &#125; if (temp.getNum()==heroNode.getNum())&#123; flag=true; break; &#125; // 后移 temp=temp.getNext(); &#125; // 修改 if (flag)&#123; temp.setName(heroNode.getName()); temp.setNickname(heroNode.getNickname()); &#125;else &#123; System.out.printf("没有找到英雄编号%d的英雄，不能修改", heroNode.getNum()); &#125; &#125; // 4.删除 public void delete(HeroNode heroNode) &#123; HeroNode temp = headNode; boolean flag = false; while (true) &#123; if (temp.getNext() == null) &#123; break; &#125; if (temp.getNext().getNum() == heroNode.getNum()) &#123; flag = true; break; &#125; temp = temp.getNext(); &#125; // 删除：temp.next=temp.next.next if (flag) &#123; temp.setNext(temp.getNext().getNext()); &#125; else &#123; System.out.printf("没有找到英雄编号%d的英雄，不能删除", heroNode.getNum()); &#125; &#125; // 遍历显示链表 public void showList() &#123; // 判断是否为空 if (headNode.getNext()==null)&#123; System.out.println("链表为空"); return; &#125; // 临时变量 HeroNode temp = headNode.getNext(); // 遍历：找到尾部元素 // 结束条件：temp.next==null while (true) &#123; if (temp == null) &#123; break; &#125; // 打印 System.out.println(temp); // temp后移 temp = temp.getNext(); &#125; &#125;&#125; 双向链表思路： 遍历 方法和单链表一样，只是可以向前查找，也可以向后查找 添加（默认添加到链表的最后） 找到双向链表的最后一个节点—&gt;while循环，break条件：node.next=null temp.next=newNode newNode.pre=temp 修改 方法与单链表一样（根据编号找到待修改的节点） 删除（双向链表可以自我删除某个节点） 找到待删除的节点temp（根据编号） temp.pre.next=temp.next 待删除节点的前一个节点的next域指向待删除节点的后一个节点 temp.next.pre=temp.pre 待删除节点的后一个节点的pre域指向待删除节点的前一个节点（如果是最后一个节点则不需要此步骤） 代码实现： 1234567891011121314151617181920212223242526@Setter@Getterpublic class DoubleHeroNode &#123; private int no; // 编号 private String name; private String nickname; private DoubleHeroNode pre; //指向前一个节点的域 private DoubleHeroNode next; //指向后一个节点的域 // 构造器 public DoubleHeroNode(int no, String name, String nickname) &#123; this.no = no; this.name = name; this.nickname = nickname; &#125; @Override public String toString() &#123; return "DoubleHeroNode&#123;" + "no=" + no + ", name='" + name + '\'' + ", nickname='" + nickname + '\'' + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class DoubleLinkedList &#123; // 初始化一个头结点 private DoubleHeroNode head = new DoubleHeroNode(0, "", ""); /** * 遍历链表 */ public void showList() &#123; // 校验链表是否为空 if (head.getNext() == null) &#123; System.out.println("链表为空..."); return; &#125; // 头节点不动----辅助节点 DoubleHeroNode temp = head.getNext(); // 循环遍历 while (true) &#123; if (temp == null) &#123; // 结束条件 break; &#125; // 输出节点信息 System.out.println(temp); // temp指针后移 temp = temp.getNext(); &#125; &#125; /** * 添加节点：在尾部添加 * @param newHeroNode */ public void add(DoubleHeroNode newHeroNode) &#123; // 找到双向链表的最后一个节点---&gt;`while循环，break条件：node.next=null` // 头节点不动----辅助节点 DoubleHeroNode temp = head; while (true) &#123; if (temp.getNext() == null) &#123; // 找到最后一个节点 break; &#125; // 指针后移 temp = temp.getNext(); &#125; // 在最后一个节点后面添加节点 temp.setNext(newHeroNode); newHeroNode.setPre(temp); &#125; /** * 修改节点 * * @param heroNode */ public void update(DoubleHeroNode heroNode) &#123; // 根据编号找到待修改的节点---循环遍历 DoubleHeroNode temp = head.getNext(); boolean flag = false; while (true) &#123; if (temp == null) &#123; // 找到最后一个节点 break; &#125; if (temp.getNo() == heroNode.getNo()) &#123; // 找到待修改的节点 flag = true; break; &#125; // temp后移 temp = temp.getNext(); &#125; // 修改 if (flag) &#123; temp.setName(heroNode.getName()); temp.setNickname(heroNode.getNickname()); &#125; else &#123; System.out.printf("没有找到 编号 %d 的节点，不能修改\n", heroNode.getNo()); &#125; &#125; /** * 删除节点：根据编号 * @param no */ public void delete(int no) &#123; // 判断当前链表是否为空 if (head.getNext() == null) &#123;// 空链表 System.out.println("链表为空，无法删除"); return; &#125; // 根据编号找到待删除的节点 DoubleHeroNode temp = head.getNext(); boolean flag = false; while (true) &#123; if (temp == null) &#123; // 找到最后一个节点 break; &#125; if (temp.getNo() == no) &#123; // 找到待修改的节点 flag = true; break; &#125; // temp后移 temp = temp.getNext(); &#125; if (flag) &#123; // 删除节点 temp.getPre().setNext(temp.getNext()); // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针 if (temp.getNext() != null) &#123; temp.getNext().setPre(temp.getPre()); &#125; &#125; else &#123; System.out.printf("要删除的 %d 节点不存在\n", no); &#125; &#125;&#125; 单向环形链表约瑟夫问题Josephu问题为：设编号为1，2，…n的n个人围坐一圈，约定编号为k（l&lt;=k&lt;=n)的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。 单向环形链表 单向环形链表解决约瑟夫问题 约瑟夫问题—创建单向环形链表示意图 123456789@Setter@Getterpublic class Boy &#123; private int no; private Boy next; // 指向下一个节点，默认null public Boy(int no) &#123; this.no = no; &#125;&#125; 按编号添加节点并形成环 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class CircleSingleLinkedList &#123; // 创建first节点 private Boy first = null; /** * 根据序号添加boy节点，形成环形 * * @param nums：节点数量 */ public void addBoys(int nums) &#123; // 传参校验 if (nums &lt; 1) &#123; System.out.println("传入的参数不正确"); return; &#125; // 辅助指针 Boy curBoy = null; // 循环添加Boy，根据编号顺序形成环形 for (int i = 1; i &lt;= nums; i++) &#123; // 根据编号创建boy节点 Boy boy = new Boy(i); // 如果是第一个节点 if (i == 1) &#123; first = boy; first.setNext(first); // 形成环 curBoy = first; &#125; else &#123; curBoy.setNext(boy); boy.setNext(first); // 形成环 curBoy = boy; &#125; &#125; &#125; /** * 遍历链表 */ public void showList() &#123; // 判断链表是否为空 if (first == null) &#123; System.out.println("链表为空..."); return; &#125; // 辅助指针 Boy temp = first; while (true) &#123; System.out.println("小孩的编号为：" + temp.getNo()); if (temp.getNext() == first) &#123; //终止条件 break; &#125; // temp后移 temp = temp.getNext(); &#125; &#125;&#125; 约瑟夫问题—小孩出圈思路示意图 创建辅助指针firstBehind，指向环形链表的最后一个节点（跟在first节点的后面） 从第k个人开始报数：first和firstBehind同时向前移动k-1次 数m下：first和firstBehind同时向前移动m-1次 此时first指针指向的节点就是要出圈的节点 first=first.next firstBehind.next=first 原来first指向的节点就没有任何引用，会被回收 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class CircleSingleLinkedList &#123; // 创建first节点 private Boy first = null; /** * 约瑟夫问题：小孩出圈 * @param startNo：起始编号 * @param coutNum：数几下 * @param totalNums：总数 */ public void JosephuBoy(int startNo, int coutNum, int totalNums) &#123; // 参数校验 if (first == null || startNo &lt; 1 || startNo &gt; totalNums) &#123; System.out.println("参数传递不合理..."); return; &#125; // 辅助指针：指向环形链表的最后一个节点（跟在first节点的后面） Boy firstBehind = first; while (true) &#123; if (firstBehind.getNext() == first) &#123; // 指向环形链表的最后一个节点 break; &#125; firstBehind = firstBehind.getNext(); &#125; // 报数前：first和firstBehind同时向前移动startNo-1次 for (int i = 0; i &lt; startNo - 1; i++) &#123; first = first.getNext(); firstBehind = firstBehind.getNext(); &#125; // 报数时：first和firstBehind同时向前移动coutNum-1次，此时first指针指向的节点就是要出圈的节点 while (true) &#123; if (firstBehind == first) &#123; //只有一个节点 break; &#125; // first和firstBehind同时向前移动coutNum-1次 for (int i = 0; i &lt; coutNum - 1; i++) &#123; first = first.getNext(); firstBehind = firstBehind.getNext(); &#125; // 此时first指针指向的节点就是要出圈的节点:删除节点 System.out.println("出圈小孩序号：" + first.getNo()); first = first.getNext(); firstBehind.setNext(first); &#125; System.out.println("最后留在圈中的小孩：" + first.getNo()); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows下部署PyTorch的C++端(LibTorch)]]></title>
    <url>%2F2019%2F06%2F20%2FWindows%E4%B8%8B%E9%83%A8%E7%BD%B2PyTorch%E7%9A%84C-LibTorch%2F</url>
    <content type="text"><![CDATA[前言环境的安装和配置： - Win10 - CMake - LibTorch 版本为stable(1.1)，注：pytorch训练模型的版本必须与libtorch的版本一致。 - OpenCV - Visual Studio 2017 部署步骤1.CMake构建项目 新建一个文件夹libTorchDemo,在该文件夹下新建CMakeLists.txt和main.cpp文件，目录结构大概如下： 123-- libTorchDemo - CMakeLists.txt - main.cpp CMakeLists.txt中配置libtorch和opencv，路径根据自己的填，具体内容如下： 123456789101112131415161718cmake_minimum_required(VERSION 3.12 FATAL_ERROR)project(LibtorchDemo)set(CMAKE_PREFIX_PATH "E:\\Libtorch\\libtorch\\share\\cmake\\Torch";E:\\opencv\\opencv\\build\\x64\\vc15\\lib)find_package(Torch REQUIRED)find_package(OpenCV REQUIRED)if(NOT Torch_FOUND) message(FATAL_ERROR "Pytorch Not Found!")endif(NOT Torch_FOUND)message(STATUS "Pytorch status:")message(STATUS " libraries: $&#123;TORCH_LIBRARIES&#125;")message(STATUS "OpenCV library status:")message(STATUS " version: $&#123;OpenCV_VERSION&#125;")message(STATUS " libraries: $&#123;OpenCV_LIBS&#125;")message(STATUS " include path: $&#123;OpenCV_INCLUDE_DIRS&#125;")include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)add_executable(LibtorchDemo main.cpp)target_link_libraries(LibtorchDemo $&#123;TORCH_LIBRARIES&#125; $&#123;OpenCV_LIBS&#125;)set_property(TARGET LibtorchDemo PROPERTY CXX_STANDARD 11) 在libTorchDemo目录下，执行CMake命令，构建项目cmake -DCMAKE_BUILD_TYPE=Release -G &quot;Visual Studio 15 Win64&quot; 至此，一个X64的release项目就构建完成，用VS2017打开此项目工程，将LibtorchDemo设为启动项。 2.将 pytorch 的模型转化为 libtorch 可用的 torchscript 模型一般情况下pytorch的模型导出格式为 .pth 格式，需要将这个格式转为 .pt 才能在C++中调用。参考代码：123456789101112import torch import torchvision # 加载模型checkpoint = torch.load(r"D:\scripts\simple_facenet\log\checkpoint_epoch1610.pth")model.load_state_dict(checkpoint['state_dict'])model.cuda()model.eval()# 向模型中输入数据以得到模型参数 example = torch.rand(1,3,182,182).cuda() traced_script_module = torch.jit.trace(model,example)# 保存模型traced_script_module.save("torch_script_eval.pt") 3.在main.cpp中重写python中的测试代码参考代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;opencv2/opencv.hpp&gt;#include "torch/script.h"#include "torch/torch.h"#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;// resize并保持图像比例不变cv::Mat resize_with_ratio(cv::Mat&amp; img) &#123; cv::Mat temImage; int w = img.cols; int h = img.rows; float t = 1.; float len = t * std::max(w, h); int dst_w = 224, dst_h = 224; cv::Mat image = cv::Mat(cv::Size(dst_w, dst_h), CV_8UC3, cv::Scalar(128,128,128)); cv::Mat imageROI; if(len==w) &#123; float ratio = (float)h/(float)w; cv::resize(img,temImage,cv::Size(224,224*ratio),0,0,cv::INTER_LINEAR); imageROI = image(cv::Rect(0, ((dst_h-224*ratio)/2), temImage.cols, temImage.rows)); temImage.copyTo(imageROI); &#125; else &#123; float ratio = (float)w/(float)h; cv::resize(img,temImage,cv::Size(224*ratio,224),0,0,cv::INTER_LINEAR); imageROI = image(cv::Rect(((dst_w-224*ratio)/2), 0, temImage.cols, temImage.rows)); temImage.copyTo(imageROI); &#125; return image;&#125;int main(int argc, const char* argv[])&#123; if (argc != 2) &#123; std::cerr &lt;&lt; "usage: example-app &lt;path-to-exported-script-module&gt;\n"; return -1; &#125; cv::VideoCapture stream(0); cv::namedWindow("Gesture Detect", cv::WINDOW_AUTOSIZE); std::shared_ptr&lt;torch::jit::script::Module&gt; module = torch::jit::load(new-mobilenetv2-128_S-win-cpu.pt); module-&gt;to(at::kCUDA); cv::Mat frame; cv::Mat image; cv::Mat input; while(1) &#123; stream&gt;&gt;frame; image = resize_with_ratio(frame); imshow("resized image",image); //显示摄像头的数据 cv::cvtColor(image, input, cv::COLOR_BGR2RGB); // 下方的代码即将图像转化为Tensor，随后导入模型进行预测 torch::Tensor tensor_image = torch::from_blob(input.data, &#123;1,input.rows, input.cols,3&#125;, torch::kByte); tensor_image = tensor_image.permute(&#123;0,3,1,2&#125;); tensor_image = tensor_image.toType(torch::kFloat); tensor_image = tensor_image.div(255); tensor_image = tensor_image.to(torch::kCUDA); torch::Tensor result = module-&gt;forward(&#123;tensor_image&#125;).toTensor(); auto max_result = result.max(1, true); auto max_index = std::get&lt;1&gt;(max_result).item&lt;float&gt;(); if(max_index == 0) cv::putText(frame, "paper", &#123;40, 50&#125;, cv::FONT_HERSHEY_PLAIN, 2.0, cv::Scalar(0, 255, 0), 2); else if(max_index == 1) cv::putText(frame, "scissors", &#123;40, 50&#125;, cv::FONT_HERSHEY_PLAIN, 2.0, cv::Scalar(0, 255, 0), 2); else cv::putText(frame, "stone", &#123;40, 50&#125;, cv::FONT_HERSHEY_PLAIN, 2.0, cv::Scalar(0, 255, 0), 2); imshow("Gesture Detect",frame); //显示摄像头的数据 cv::waitKey(30); &#125;]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>LibTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake开箱体验]]></title>
    <url>%2F2019%2F06%2F13%2FCMake%E5%BC%80%E7%AE%B1%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[CMake是什么是一种make工具，一个比例如QT的qmake，微软的 MS nmake make 更高级的编译配置工具，因为它的跨平台性更好，从而做到“Write once, run everywhere” 它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程 然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程 怎么用在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下： 编写 CMake 配置文件 CMakeLists.txt ； 执行命令 cmake PATH或者 ccmake PATH 生成 Makefile 。其中，PATH 是 CMakeLists.txt 所在的目录; 使用make命令进行编译。 注：在Windows平台下编译使用如下命令：cmake --build .(Debug版本) cmake --build . --config Release(Release版本)入门案例单个源文件假设现在有个项目Demo1。对于简单的项目，只需要写几行代码就可以了。例如，假设现在我们的Demo1项目中只有一个源文件 main.cpp 1.编写 CMakeLists.txt CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 # 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。 在main.cpp同目录下新建一个CMakeLists.txt文件，编写如下内容: 123456# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo1)# 指定生成目标add_executable(Demo main.cpp) 说明：add_executable： 将名为 main.cpp 的源文件编译成一个名称为 Demo 的可执行文件。 2.编译项目 在当前目录执行 cmake .，得到 Makefile 后再使用make(win平台下用cmake –build)命令编译得到一个名为 Demo 的可执行文件。 多个源文件同一目录，多个源文件假设现在有个项目Demo2。项目结构如下1234567./Demo2 | +--- main.cpp | +--- MathFunctions.cpp | +--- MathFunctions.h 这时的 CMakeLists.txt 如下: 123456# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo2)# 指定生成目标add_executable(Demo main.cpp MathFunctions.cpp) 唯一的改动只是在add_executable命令中增加了一个MathFunctions.cpp源文件。这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用aux_source_directory命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下： 1aux_source_directory(&lt;dir&gt; &lt;variable&gt;) 因此，可以修改为： 123456789# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo2)# 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable(Demo $&#123;DIR_SRCS&#125;) 多个目录，多个源文件假设现在有个项目Demo3。项目结构如下 123456789./Demo3 | +--- main.cpp | +--- math/ | +--- MathFunctions.cpp | +--- MathFunctions.h 对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。 根目录中的 CMakeLists.txt ： 12345678910111213# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo3)# 查找当前目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 添加 math 子目录add_subdirectory(math)# 指定生成目标 add_executable(Demo main.cc)# 添加链接库target_link_libraries(Demo MathFunctions) 该文件添加了下面的内容: 第3行，使用命令add_subdirectory指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理 。第6行，使用命令target_link_libraries指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。 子目录中的 CMakeLists.txt： 12345# 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 生成链接库add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;) 在该文件中使用命令add_library将 src 目录中的源文件编译为静态链接库。 其他常用命令添加版本号12set (Demo1_VERSION_MAJOR 1)set (Demo1_VERSION_MINOR 0) 设置include文件1234INCLUDE_DIRECTORIES($&#123;OPENCV_INCLUDE_DIR&#125;$&#123;PROJECT_SOURCE_DIRECTORY&#125;) 设置lib 文件1link_directories($&#123;OpenCV_LIBRARY_DIR&#125;) 查找是否安装了OpenCV1234FIND_PACKAGE(OpenCV REQUIRED )IF($&#123;OpenCV_VERSION&#125; VERSION_LESS 3.4.5) MESSGAE(FATAL_ERROR “OPENCV version is not compatible: $&#123;OpenCV_VERSION&#125;&quot;)ENDIF() 配置opencv前提是opencv的环境变量设置好1234find_package(OpenCV REQUIRED)include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)target_link_libraries(Demo $&#123;OpenCV_LIBS&#125;)Demo是你项目要生成的exe或者动态库名字 参考：CMake入门实战]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源项目的学习-基于Java的Halo博客系统]]></title>
    <url>%2F2019%2F05%2F29%2F%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E4%BA%8EJava%E7%9A%84Halo%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[玩转一个开源项目路线 了解项目是干什么的 了解项目的技术点 在本地跑起来 阅读源码并调试 能修改、添加功能模块 1.Halo是干什么的 阅读README.md文档是拿到每个项目的第一件事 通过readme文档知道Halo是基于Java的动态博客系统，意味着完全界面化的操作，在网页中写文章即可发布。 2.技术点 项目管理工具是Gradle 后端使用Spring Boot 这是作者的原话：Halo 的诞生离不开下面这些项目： Spring Boot：Spring 的快速开发框架 Freemarker：模板引擎，使页面静态化 H2 Database：嵌入式数据库，无需安装 Spring-data-jpa：不需要写 sql 语句的持久层框架 Ehcache：缓存框架 Lombok：让代码更简洁 oh-my-email：可能是最小的 Java 邮件发送库了，支持抄送、附件、模板等 Hutool：一个 Java 基础工具类库 Thumbnailator：缩略图生成库 AdminLTE：基于 Bootstrap 的后台模板 Bootstrap：使用最广泛的前端 ui 框架 Animate：非常好用的 css 动效库 SimpleMDE - Markdown Editor：简洁，功能够用，且轻量级的 Markdown 编辑器 Bootstrap-FileInput：基于 Bootstrap 的文件上传组件 Font-awesome：使用最广泛的字体图标库 JQuery：使用最广泛的 JavaScript 框架 Layer：个人认为最实用最好看的弹出层组件，没有之一 JQuery-Toast：消息提示组件 Pjax：pushState + ajax = pjax OwO：前端表情库 3.本地启动 在Github克隆Halo项目git clone https://github.com/halo-dev/halo.git 打开IntelliJ IDEA导入项目初次导入，要加载很久，耐心等待吧，导入完成后如下： 点击运行，浏览器输入运行成功后给出的地址 源码解读1.项目结构这是一个基于Spring Boot的项目 首先看项目管理文件build.gradle文件是项目管理文件，里面有各种依赖（dependencies），Maven则是以xml形式的各种依赖。 再看src目录其他不用管，src目录下的就是源码，其中test目录下为测试用，可以不用看resources为资源文件主要是一些前端的东西，可以打开看一下。其中application.yaml为配置文件，例如端口号什么的，可以进行修改。main为Java代码文件找到入口：这里是Application文件 接下来先看controller(控制层)，再看service层(服务层)，一个对应一个，慢慢看下去。需要耐心。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Java</tag>
        <tag>IDEA</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL入门到跑路]]></title>
    <url>%2F2019%2F05%2F29%2FMySQL%E5%85%A5%E9%97%A8%E5%88%B0%E8%B7%91%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[数据库简介 关系型数据库： 基于E-R模型（实体-关系） 使用sql语句进行操作 分类：文档型（sqlite：移动终端）、服务型 数据库设计： 三范式：列不可拆分（数据拆到不能再拆，具体问题具体分析）、唯一标识（保证唯一性）、引用主键（引用唯一标识建立关系）； 关系及储存： 1对1：一个对象A对应一个对象B，一个对象B对应一个对象A eg：一个班级只有一个学生，一个学生对应着一个班级。则关系可以存入A或B对象中都可以； 1对多：一个对象A对应着n个对象B，一个对象B对应着一个对象A eg：一个班级有n个学生，一个学生对应着一个班级。则关系存入B对象（多）； 多对多：一个对象A对应n个对象B，一个对象B对应m个对象A 。则新建表AB，专门存关系，用标识填充数据。 SQL语法入门语句 连接服务器 ：mysql -u 用户名 -p 密码 查看所有库： show database 选库语句：use 库名； 查看库下的表：show tables； 查看表结构：desc class； 创建数据库：create database 库名 charset utf8； 删除数据库：drop database 库名； MySQL中表、列可以改名，database不能改名 建表：create table stu（Snum int，Sname varchar(10)) engine myisam charset utf8; 删除表：drop table stu； 给表改名：rename table stu to newstu; 插入语句：insert into stu values (1,&#39;zhangsan&#39;),(2,&#39;lisi&#39;),(3,&#39;wangwu&#39;); 查询语句：select * from stu； 清空表数据：truncate stu； 增删改查(基本) 1.建表：CREATE语句 123456789CREATE TABLE `test`.`class` (`id` int(255) NOT NULL AUTO_INCREMENT,`sname` varchar(10) CHARACTER SET utf8 NOT NULL DEFAULT &apos;&apos;,`gender` char(1) CHARACTER SET utf8 NOT NULL DEFAULT &apos;&apos;,`company` varchar(20) CHARACTER SET utf8 NOT NULL DEFAULT &apos;&apos;,`salary` decimal(6, 2) NOT NULL DEFAULT &apos;&apos;,`fanbu` smallint(20) NOT NULL DEFAULT &apos;&apos;,PRIMARY KEY (`id`)); 2.添加语句：INSERT语句 1INSERT INTO `test`.`class`(`sname`, `gender`, `salary`, `fanbu`) VALUES (&apos;李四&apos;, &apos;男&apos;, 5000.00, 200)； 如果插入所有列，则可以不声明列名：INSERT INTO test.class VALUES (3,’zlatan’, ‘男’,’Blibli’ ,8000.00, 500);注意：id虽然为自增型，但是插入的时候还是要写，或者写null占位；插入多行用逗号隔开； 3.修改语句：UPDATE语句12update 表名 set 列1=新值，列2=新值 where id=4；UPDATE test.class SET fanbu=159 WHERE &apos;gender&apos;=&apos;男&apos; AND &apos;salary&apos;&gt;8000.00; where 表达式为真则执行生效，不一定为id，一定要加生效行，不然这一列全改了，问题很严重 4.删除语句：DELETE1delete from class where salary&gt;8500 删除是指删除整行 5.查询语句：SELECT语句123select sname,fanbu from class where id=3; //取部分列，单行；select *from class //取所有行所有列，*代表所有列，表名后不加where条件，则选所有行；select sanme，fanbu from class //取部分列，所有行； 对列的操作(alter table) 1.加一列在表的最后：alter table 表名 add 列名称 列类型 列参数； 2.加一列在指定列后：alter table 表名 add 列名称 列类型 列参数 after 某列； 3.加一列在表的最前面：alter table 表名 add 列名称 列类型 列参数 first； 4.删除列：alter table 表名 drop 列名； 5.修改列：alter table 表名 modify 列名 列类型 列参数----------modify不能改列名，要用change； 6.修改列名和列参数：alter table 表名 change 旧列名 新列名 列类型 列参数； 字段类型（建表用）列类型：不同的列类型，所占据的空间和效率是不一样的，主要讨论列类型的存储范围与占据字节的关系 整型int系列声明时的参数（M）、unsigned 、zeroFill MySQL还支持选择在该类型关键字后面的括号内指定整数值的显示宽度(例如，INT(4))。该可选显示宽度规定用于显示宽度小于指定的列宽度的值时从左侧填满宽度。显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。 不加特殊说明时，默认有符号；加unsigned表示无符号，可以影响存储范围；M必需配合zeroFill使用才有意义：M表示补零宽度，和zerofill一起使用（保证位数相同），zerofill默认是unsigned类型；如添加一列类型为smallint的字段：alter table cd add num smallint(5) zerofill not null default 0 浮点型float（M，D）；decimal（M，D）M 叫标度—-&gt;代表总位数、D是精度—-&gt;代表小数点右边后的位数；decimal精度更高，float有时候会损失精度； 字符型 日期、时间类型 建表实战社交网站会员表 member 查询进阶查询模型： 列看成变量，where后面跟的是表达式，定位到列，一行一行的匹配判断，表达式为真则执行 既然是变量，就可以进行计算，即意味着可以组合成新的列进行查询显示 进阶查询 where条件查询 group by 分组 having 筛选 order by 排序 limit 限制结果条数 where查询商品表：goods 字段：Goods_id、Cat_id、Goods_sn、Click_count、Goods_number、Market_price、Shop_price、Add_time、Is_best、Is_new、Is_hot 把其他表的数据（shop.goods）插入到本表中(test.goods)1Insert into test.goods select Goods_id,Cat_id,Goods_sn,Click_count,Goods_number,Market_price,Shop_price,add_time,is_best,is_new,is_hot from shop.goods 1.1、查询商品主键为32的商品； Select goods_id,goods_name,shop_price from goods where goods_id=32; 1.2、不属于第3栏目的所有商品； Select goods_id,cat_id,goods_number from goods where cat_id !=3; !=等价于&lt;&gt; 1.3、本店价格高于和等于3000的商品； Select goods_id,goods_name,shop_price from goods where Shop_price&gt;=3000; 1.4、取出第4栏目和第11栏目的商品； Select goods_id,goods_name,shop_price from goods where cat_id in (4,11); //cat_id在4，11这个集合里都满足 1.4.1、取出不属于第3栏目且不属于第11栏目的商品； Select goods_id,goods_name,shop_price from goods where cat_id not in (3,11);Select goods_id,goods_name,shop_price from goods where cat_id !=3 and cat_id !=11 ; 1.5、取出价格在100到500之间的商品； Select goods_id,goods_name,shop_price from goods where Shop_price between 100 and 500； 1.6、取出价格大于100且小于300，或者大于4000且小于5000的商品； Select goods_id,goods_name,shop_price from goods where shop_price&gt;100 and shop_price&lt;300 or shop_price&gt;4000 and shop_price&lt;5000; //and优先级比or高 1.7、取出第3个栏目下价格小于1000或者大于3000，同时点击量大于等于5的商品； Select goods_id,goods_name,shop_price,click_count from goods where cat_id=3 and (shop_price&lt;1000 or shop_price&gt;3000) and click_count&gt;=5; 1.8、查出以“诺基亚”开头的商品；#模糊查询； Select goods_id,goods_name,shop_price,click_count from goods where goods_name like &#39;诺基亚%&#39;; //其中“%”能取出任意字符，“_”匹配单一字符Select goods_id,goods_name,shop_price,click_count from goods where goods_name like &#39;诺基亚N__&#39;; //查出诺基亚N加两个字符的商品 1.9、查出本店价格比市场价格的差值； Select goods_id,goods_name,market_price-shop_price from goods;Select goods_id,goods_name,(market_price-shop_price) as discount from goods; //以discount 显示Select goods_id,goods_name,(market_price-shop_price) as discount from goods where (market_price-shop_price)&gt;200; //查出差值大于200商品，where后不能是discount 练习题：有如下表和数组，把num值处于[20,29]之间，改为20，num值处于[30,39]之间的，改为30； `把num当成变量看，num/10取整，再乘以10 Update table set num=floor(num/10)*10 where num&gt;=20 and num&lt;=39;` group与统计函数五个函数：max(求最大)、min(求最小)、sum(求和)、avg(求平均)、count(求总行数) 1.10.查出最贵商品的价格 select max(shop_price) from goods 1.11.查出库存量是多少 select sum(goods_number) from goods 1.12.查出商品的平均价格 select avg(shop_price) from goods 1.13.查出总共有多少种商品 select count(*) from goods 哪怕所有字段都为null select count(字段) from goods 字段不为null才计数 上面5个统计函数，单独使用，意义不大，要和group分组配合使用 1.14.第三个栏目下商品库存量 select sum(goods_number) from goods where cat_id=3 1.15.一次计算完，每个栏目下的库存之和 select cat_id,sum(goods_number) from goods group by cat_id having筛选(对结果集筛选)对结果集筛选，因此要放到where、group by后面 语法：having 结果集中的列名 条件 1.16.查询每种商品所积压的货款（商品库存*价格） select goods_id,shop_price,goods_number,shop_price*goods_number as hk from goods 1.17.查询积压的总货款 select sum(shop_price*goods_number) from goods 1.18.查询每个栏目下积压的货款 select cat_id,sum(shop_price*goods_number) from goods group by cat_id 1.19.查询积压货款超过2w的栏目，以及该栏目积压的货款 select cat_id,sum(shop_price*goods_number) as hk from goods group by cat_id having hk&gt;20000 1.20.查询本店价比市场价省的钱，其省钱大于200的商品 select goods_id,market_price-shop_price as sq from goods having sq&gt;200 1.21.有如下表:查询出2门及2门以上不及格的平均成绩 即算出张三的平均成绩和李四的平均成绩 name subject score 张三 数学 90 张三 语文 50 张三 地理 40 李四 语文 55 李四 政治 45 王五 政治 30 a.先算出每个人的平均分 select name,avg(score) from table group by name b.想办法统计出每个人的挂科情况 select name,score&lt;60 as gk from table group by name c.整合a和b并筛选 select name,avg(score),sum(score&lt;60) as gks from table group by name having gks&gt;=2 order by 和 limitorder by对结果集排序，因此要放到where、group、having后面 语法：order by 结果集中的列名 desc/asc 1.22.取第四栏目下的商品，并按价格由高到低排序 select goods_id,goods_name,shop_price from goods where cat_id=4 order by shop_price desc 1.23.按栏目升序排列，在栏目内部再按商品价格降序排列 select goods_id,goods_name,shop_price from goods order by cat_id asc,shop price desc limit语句在最后，起到限制条目的作用 语法：limit[offset] N offset：偏移量（跳过几行）N:实际取出条数 1.24.取第四栏目下的前10个商品，并按价格由高到低排序 select goods_id,goods_name,shop_price from goods where cat_id=4 order by shop_price desc limit 10 1.25.查询出本店价格最高的前三名 select goods_id,goods_name,shop_price from goods order by shop_price desc limit 0,3 1.26.查询出本店最高的 第三名到第五名 商品 select goods_id,goods_name,shop_price from goods order by shop_price desc limit 2,3 1.27.查询出每个栏目下id号最大的一条商品 典型错误：select goods_id,goods_name,shop_price,cat_id from goods group by cat_id order by goods_id desc limit 1 错误原因：group时，MySQL是取每个分组下第一次出现的行 正解：见下一个知识点（子查询） 子查询这5个语句是要严格按照 where-&gt;group by-&gt;having-&gt;order by-&gt;limit 的顺序采符合语法 子查询where子查询把内层查询的结果作为外层查询的比较条件 1.28.查出本网站最新的一条商品 select goods_id,goods_name from goods order by goods_id desc limit 0,1 1.29.查出本网站最新的一条商品,不用排序 select goods_id,goods_name from goods where goods_id in (selcet max(goods_id) from goods) 1.30.查询出每个栏目下最新的一条商品 select goods_id,goods_name from goods where goods_id in (select max(cat_id) from goods group by cat_id) from子查询查询结果集-结构上可以当成表-&gt;意味着可以再次查询内层sql的查询结果，当成一张临时表，供外层sql再次查询。 1.31.查询出每个栏目下最新的一条商品 select * from (select goods_id,goods_name from goods order by cat_id asc,goods_id desc) as tmp group by cat_id exits子查询把外层子查询的结果，拿到内层sql去测试，如果内层sql成立，则改行取出 1.32.查出有商品的栏目 新建一张category表，只有cat_id和cat_name字段。 select cat_id,cat_name from goods where exits(select * from goods where goods.cat_id=category.cat_id) 关于nullQ：建表时，列后面有 not null default ‘’/ default 0是什么意思？ A：让这个列不为null，就算没填，也有默认值。 Q：为什么不希望某个列的值为null呢？ A:null是一种类型，null的比较需要专门用is null，is not null来比较 效率不高，影响索引效果 字段有关联的多表子查询左连接表与集合的联系：一张表就是一个集合；每一行就是集合的一个元素。 两表做全相乘从行的角度看：就是两表的每一行 两两组合从列的角度看：结果集中的列，就是两表列名的相加 可以选择性的选出想要查询的列名在多表联查时，某一列名，在2张或2张以上表都有，则需要在列名前指定表名，即 表名.列名 1.32 查询出所有商品的名称、栏目类型、库存、价格用两表全相乘来查询 select goods_id,goods_name,goods_number,shop_price,cat_name from goods,category where goods.cat_id=category.cat_id 但是全相乘耗内存，也没用到索引，效率非常低 左连接语法：假设A表在左边，B表在A表的右边滑动A表与B表通过一个关系来筛选B表的行 语法：A left join B on 条件 形成的也是一个结果集，即可以看成一张表 条件为真，则B表对应的行取出 select goods_id,goods_name,goods_number,shop_price,cat_name from goods left join category on goods.cat_id=category.cat_id 1.32 取出第四个栏目下的商品，以及商品的栏目名 select goods_id,cat_id，goods_name,cat_name from goods left join category on goods.cat_id=category.cat_id where goods.cat_id=4 左连接、右连接、内连接的区别 内连接：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。 左连接：左(外)连接，左表的记录将会全部表示出来，而右表只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。 右连接：与左(外)连接相反，右(外)连接，左表只会显示符合搜索条件的记录，而右表的记录将会全部表示出来。左表记录不足的地方均为NULL。 练习：有match表 字段 类型 备注 matchID int 主键 hostTeamID int 主队的ID guestTeamID int 客队的ID matchResult varchar(20) 比赛结果 matchTime date 比赛时间 具体如下：m mid hid gid mres matime 1 1 2 2:0 2019-04-13 2 2 3 1:2 2019-04-14 3 3 1 2:5 2019-04-15 4 2 1 3:2 2019-04-16 参赛队伍表team 字段名称 字段类型 备注 teamID int 主键 teamName varchar(20) 队伍名称 具体如下：t tid tname 1 国安 2 申花 3 卓尔 要求取出比赛结果，显示出队名。如：国安 2:0 申花 2019-05-23 1.select hid,tname,mres,gid,matime from m left join t on m.hid=t.tid 结果如下： hid tname mres gid matime 1 国安 2:0 2 2019-04-13 2 申花 1:2 3 2019-04-14 3 卓尔 2:5 1 2019-04-15 2 申花 3:2 1 2019-04-16 2.select hid,t1.tname,mres,gid,t2.tname,matime from m left join t as t1 on m.hid=t1.tid left join t as t2 on m.gid=t2.tid 结果如下： hid tname mres gid tname matime 1 国安 2:0 2 申花 2019-04-13 2 申花 1:2 3 卓尔 2019-04-14 3 卓尔 2:5 1 国安 2019-04-15 2 申花 3:2 1 国安 2019-04-16 总结：把这张表需要的字段选出来即可。连了两次，三表联查 unionunion查询就是把2条或者多条sql语句的查询结果，合并成一个结果集。 Q: 取自于2张表,通过”别名”让2个结果集的列一致。那么,如果取出的结果集,列名字不一样,还能否union? A: 可以,而且取出的最终列名,以第1条sql为准. Q: union满足什么条件就可以用了? A: 只要结果集中的列数一致就可以.（如都是2列或者N列）。 Q: 如果Union后的结果有重复(即某2行,或N行,所有的列,值都一样),怎么办? A:默认去重，如不想去重，用union all。 练习：有如下两张表：num_a和num_b表 num_a表 id num a 5 b 10 c 15 d 10 num_b表 id num b 5 c 15 d 25 e 30 1.SELECT id,num FROM num_a UNION SELECT id, num FROM num_b 结果如下：会去掉重复的行c-15 id num a 5 b 10 c 15 d 10 b 5 d 25 e 30 2.UNION ALL不会过滤重复的行:SELECT id,num FROM num_a UNION ALL SELECT id, num FROM num_b 3.order by对union后的结果集排序:SELECT id,num FROM num_a UNION SELECT id, num FROM num_b ORDER BY num DESC id num e 30 d 25 c 15 b 10 d 10 a 5 b 5 4.把num_a和num_b不同的索引结果保留,相同的索引结果相加,然后输出：如下结果 id num a 5 b 15 c 30 d 35 e 30 分组统计union后的表：select id,sum(num) as num from (select id,num from num_a union all select id,num from num_b) group by id MySQL中的函数 数学函数 字符串函数 日期和时间函数 条件判断函数 系统信息函数 加密函数 格式化函数 参考地址 注意： MySQL函数肯定是要影响查询速度，应该在建表时，通过合理的表结构减少函数的使用。 数据库最好只做简单的数据插入和查询操作等操作，逻辑运算由应用程序来做。 最大的弊端;针对某列查询，而此列用了函数，则此列不再使用索引。 视图view在查询中，经常把查询结果当成表来看，如果一个结果集频繁用到，则可以用view，看成一张虚拟表，是表通过运算得到的一个投影。 视图的作用 简化查询：比如复杂的查询，先用视图生成一个中间结果，再查询视图 更精细的权限控制：比如有些字段不想开放权限 数据多，分表用 创建视图的语法Q：如何创建视图，建视图的时候，需要指定视图的列名与列类型吗？ A：不需要，它是个影子，继承了上面的字段，只是一种关系。 示例：create view 视图名 as select 语句 表与视图数据变化时相互影响问题 表的数据变化会影响到视图 大多数情况下视图的值不能更改 视图数据变化会影响到表：视图的数据和表的数据是一一对应]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大经典排序算法]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[十大经典排序算法排序算法是《数据结构与算法》中最基本的算法之一。排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。 常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。用一张图概括： 关于时间复杂度： 平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。 线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序； O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序 线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。 关于稳定性： 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 名词解释： n：数据规模 k：“桶”的个数 In-place：占用常数内存，不占用额外内存 Out-place：占用额外内存 稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同 GitBook 内容大纲 冒泡排序冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 动图演示 什么时候最快当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。 什么时候最慢当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。 Python 代码实现123456def bubbleSort(arr): for i in range(1, len(arr)): for j in range(0, len(arr)-i): if arr[j] &gt; arr[j+1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr Java 代码实现12345678910111213141516171819202122232425262728public class BubbleSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i &lt; arr.length; i++) &#123; // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 选择排序选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 动图演示 Python 代码实现1234567891011def selectionSort(arr): for i in range(len(arr) - 1): # 记录最小数的索引 minIndex = i for j in range(i + 1, len(arr)): if arr[j] &lt; arr[minIndex]: minIndex = j # i 不是最小数时，将 i 和最小数进行交换 if i != minIndex: arr[i], arr[minIndex] = arr[minIndex], arr[i] return arr Java 代码实现1234567891011121314151617181920212223242526272829public class SelectionSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 总共要经过 N-1 轮比较 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; // 记录目前能找到的最小值元素的下标 min = j; &#125; &#125; // 将找到的最小值和i位置所在的值进行交换 if (i != min) &#123; int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; &#125; &#125; return arr; &#125;&#125; 插入排序插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。 算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 动图演示 Python 代码实现123456789def insertionSort(arr): for i in range(len(arr)): preIndex = i-1 current = arr[i] while preIndex &gt;= 0 and arr[preIndex] &gt; current: arr[preIndex+1] = arr[preIndex] preIndex-=1 arr[preIndex+1] = current return arr Java 代码实现1234567891011121314151617181920212223242526272829public class InsertSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt; arr.length; i++) &#123; // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; // 存在比其小的数，插入 if (j != i) &#123; arr[j] = tmp; &#125; &#125; return arr; &#125;&#125; 希尔排序希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 算法步骤 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 Python 代码实现12345678910111213141516def shellSort(arr): import math gap=1 while(gap &lt; len(arr)/3): gap = gap*3+1 while gap &gt; 0: for i in range(gap,len(arr)): temp = arr[i] j = i-gap while j &gt;=0 and arr[j] &gt; temp: arr[j+gap]=arr[j] j-=gap arr[j+gap] = temp gap = math.floor(gap/3) return arr&#125; Java 代码实现12345678910111213141516171819202122232425262728public class ShellSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int gap = 1; while (gap &lt; arr.length) &#123; gap = gap * 3 + 1; &#125; while (gap &gt; 0) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int tmp = arr[i]; int j = i - gap; while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = tmp; &#125; gap = (int) Math.floor(gap / 3); &#125; return arr; &#125;&#125; 归并排序归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代； 在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为： However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。 说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。 算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 动图演示 Python 代码实现1234567891011121314151617181920def mergeSort(arr): import math if(len(arr)&lt;2): return arr middle = math.floor(len(arr)/2) left, right = arr[0:middle], arr[middle:] return merge(mergeSort(left), mergeSort(right))def merge(left,right): result = [] while left and right: if left[0] &lt;= right[0]: result.append(left.pop(0)); else: result.append(right.pop(0)); while left: result.append(left.pop(0)); while right: result.append(right.pop(0)); return result Java 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MergeSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); if (arr.length &lt; 2) &#123; return arr; &#125; int middle = (int) Math.floor(arr.length / 2); int[] left = Arrays.copyOfRange(arr, 0, middle); int[] right = Arrays.copyOfRange(arr, middle, arr.length); return merge(sort(left), sort(right)); &#125; protected int[] merge(int[] left, int[] right) &#123; int[] result = new int[left.length + right.length]; int i = 0; while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if (left[0] &lt;= right[0]) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; else &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; &#125; while (left.length &gt; 0) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; while (right.length &gt; 0) &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; return result; &#125;&#125; 快速排序快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案： 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 动图演示 Python 代码实现1234567891011121314151617181920212223def quickSort(arr, left=None, right=None): left = 0 if not isinstance(left,(int, float)) else left right = len(arr)-1 if not isinstance(right,(int, float)) else right if left &lt; right: partitionIndex = partition(arr, left, right) quickSort(arr, left, partitionIndex-1) quickSort(arr, partitionIndex+1, right) return arrdef partition(arr, left, right): pivot = left index = pivot+1 i = index while i &lt;= right: if arr[i] &lt; arr[pivot]: swap(arr, i, index) index+=1 i+=1 swap(arr,pivot,index-1) return index-1def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i] Java 代码实现12345678910111213141516171819202122232425262728293031323334353637383940public class QuickSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return quickSort(arr, 0, arr.length - 1); &#125; private int[] quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr; &#125; private int partition(int[] arr, int left, int right) &#123; // 设定基准值（pivot） int pivot = left; int index = pivot + 1; for (int i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index - 1; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 堆排序堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 堆排序的平均时间复杂度为 Ο(nlogn)。 算法步骤 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 动图演示 Python 代码实现123456789101112131415161718192021222324252627282930def buildMaxHeap(arr): import math for i in range(math.floor(len(arr)/2),-1,-1): heapify(arr,i)def heapify(arr, i): left = 2*i+1 right = 2*i+2 largest = i if left &lt; arrLen and arr[left] &gt; arr[largest]: largest = left if right &lt; arrLen and arr[right] &gt; arr[largest]: largest = right if largest != i: swap(arr, i, largest) heapify(arr, largest)def swap(arr, i, j): arr[i], arr[j] = arr[j], arr[i]def heapSort(arr): global arrLen arrLen = len(arr) buildMaxHeap(arr) for i in range(len(arr)-1,0,-1): swap(arr,0,i) arrLen -=1 heapify(arr, 0) return arr Java 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HeapSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0, len); &#125; return arr; &#125; private void buildMaxHeap(int[] arr, int len) &#123; for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) &#123; heapify(arr, i, len); &#125; &#125; private void heapify(int[] arr, int i, int len) &#123; int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest, len); &#125; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 计数排序计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 动图演示 Python 代码实现123456789101112131415def countingSort(arr, maxValue): bucketLen = maxValue+1 bucket = [0]*bucketLen sortedIndex =0 arrLen = len(arr) for i in range(arrLen): if not bucket[arr[i]]: bucket[arr[i]]=0 bucket[arr[i]]+=1 for j in range(bucketLen): while bucket[j]&gt;0: arr[sortedIndex] = j sortedIndex+=1 bucket[j]-=1 return arr Java 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041public class CountingSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxValue = getMaxValue(arr); return countingSort(arr, maxValue); &#125; private int[] countingSort(int[] arr, int maxValue) &#123; int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) &#123; bucket[value]++; &#125; int sortedIndex = 0; for (int j = 0; j &lt; bucketLen; j++) &#123; while (bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr; &#125; private int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125;&#125; 桶排序桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 什么时候最快当输入的数据可以均匀的分配到每一个桶中。 什么时候最慢当输入的数据被分配到了同一个桶中。 Java 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class BucketSort implements IArraySort &#123; private static final InsertSort insertSort = new InsertSort(); @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return bucketSort(arr, 5); &#125; private int[] bucketSort(int[] arr, int bucketSize) throws Exception &#123; if (arr.length == 0) &#123; return arr; &#125; int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) &#123; if (value &lt; minValue) &#123; minValue = value; &#125; else if (value &gt; maxValue) &#123; maxValue = value; &#125; &#125; int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); &#125; int arrIndex = 0; for (int[] bucket : buckets) &#123; if (bucket.length &lt;= 0) &#123; continue; &#125; // 对每个桶进行排序，这里使用了插入排序 bucket = insertSort.sort(bucket); for (int value : bucket) &#123; arr[arrIndex++] = value; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125; 基数排序基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 基数排序 vs 计数排序 vs 桶排序基数排序有两种方法： 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶； 计数排序：每个桶只存储单一键值； 桶排序：每个桶存储一定范围的数值； LSD 基数排序动图演示 Java 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 基数排序 * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9 */public class RadixSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int maxDigit = getMaxDigit(arr); return radixSort(arr, maxDigit); &#125; /** * 获取最高位数 */ private int getMaxDigit(int[] arr) &#123; int maxValue = getMaxValue(arr); return getNumLenght(maxValue); &#125; private int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue; &#125; protected int getNumLenght(long num) &#123; if (num == 0) &#123; return 1; &#125; int lenght = 0; for (long temp = num; temp != 0; temp /= 10) &#123; lenght++; &#125; return lenght; &#125; private int[] radixSort(int[] arr, int maxDigit) &#123; int mod = 10; int dev = 1; for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; for (int j = 0; j &lt; arr.length; j++) &#123; int bucket = ((arr[j] % mod) / dev) + mod; counter[bucket] = arrayAppend(counter[bucket], arr[j]); &#125; int pos = 0; for (int[] bucket : counter) &#123; for (int value : bucket) &#123; arr[pos++] = value; &#125; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrayAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序算法</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试基础]]></title>
    <url>%2F2019%2F05%2F26%2FJava%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1.写一个方法，实现字符串的反转，如：输入abc，输出cba1234567public static String reverse(String s)&#123; int length=s.length(); StringBuffer result=new StringBuffer(length); for(int i=length-1;i&gt;=0;i--) result.append(s.charAt(i)); return result.toString(); &#125; 2.数据类型之间的转换2.1如何将数值型字符转换为数字（Integer，Double） 使用Integer.parseInt()和Double.parseDouble()方法。2.2如何将数字转换为字符String.valueOf(int a); 3.如何取小数点前两位，并四舍五入12System.out.println("四舍五入取整:(3.856)=" + new BigDecimal(i).setScale(2, BigDecimal.ROUND_HALF_UP)); 4.文件和目录（I/O）操作 如何列出某个目录下的所有文件 如何列出某个目录下的所有子目录 判断一个文件或目录是否存在 如何读写文件123456789101112131415161718192021222324252627282930313233343536373839public static void main(String [] args) &#123; FileOpreate fo=new FileOpreate(); try &#123; //文件的写入 String[] testStr=new String[50]; for(int i=0;i&lt;testStr.length;i++) &#123; testStr[i]="我的测试数据00"+i; &#125; fo.writeFile("D:\\","test.txt",testStr); //创建或者删除文件 if(fo.createAndDeleteFile("D:\\","test001.txt")) &#123; fo.createAndDeleteFile("D:\\","test002.txt"); &#125; //创建或者删除文件夹 fo.createAndDeleteFolder("D:\\","2009-07-06"); //输出一个文件内的文件名称 fo.readFolderByFile("D:\\"); //判断一个文件是否是空的 fo.fileIsNull("D:\\","test002.txt"); //读取全部的文件内容 fo.readAllFile("D:\\","test.txt"); //一行一行读取文件内容 fo.readLineFile("D:\\","test.txt"); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; 5.编码转换，怎样实现将GB2312编码的字符串转换为ISO-8859-1编码的字符串String str = new String(&quot;字符串&quot;.getBytes(&quot;GB2312&quot;),&quot;ISO-8859-1&quot;); 6.谈谈final, finally, finalize的区别final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。finally是异常处理语句结构的一部分，表示总是执行。finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。 7.Int和Integer的区别Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。原始类型封装类boolean-Boolean char-Character byte-Byte short-Short int-Integer long-Long float-Float double-Double引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。 8.ArrayList和Vector的区别,HashMap和Hashtable的区别。ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差。 9.HashMap是怎样的结构？工作原理是什么？退化成链表解决方法？HashMap的本质仍然是数组，不过数组中存储的不是数据，而是一个链表的头节点。所以准确的说，其实现就是链表数组。HashMap中保存的是一个键值对，插入对象时必须提供一个键对象；查找对象时必须给定一个键对象（因此必须记住键）。键对象时不允许重复的，但是允许null空键的存在。HashMap插入对象时，根据给定的键key计算hashcode，然后再与数组长度进行求余运算得到数组下标。然后与该位置上的链表中已存储的键进行比较，对于已存在的键，则覆盖；对于不存在的键，则添加到链表尾。HashMap工作原理： HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用LinkedList来解决碰撞问题，当发生碰撞了，对象将会储存在LinkedList的下一个节点中。 HashMap在每个LinkedList节点中储存键值对对象。当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的LinkedList中。键对象的equals()方法用来找到键值对。key对象相同则覆盖，hashcode相同则添加到链表尾。退化成链表解决方法？JDK7中确实会有这样的问题，因为链表法有这样的缺陷。但是在JDK8中，Java会在链表长度超过一个阙值的时候将链表升级为一个平衡二叉树，使用hashcode作为树的分支变量，较大的会插入到右子树中；hashcode相等的情况下，HashMap希望Key对象是实现了Comparable接口的，这样就可以按照顺序插入。键对象的选择-&gt;选择String对象作为键对象最好，因为String具有不可变性。 10.什么是堆内存？什么是栈内存？有什么区别？Java的内存空间分为堆内存和栈内存。栈内存用于存储定义的基本类型变量、函数返回值、对象的引用等，而堆内存用于存放new出来的一切对象 11.Java里常用的工具类 org.apache.commons.io.IOUtils1、closeQuietly 关闭一个IO流、socket、或者selector且不抛出异常。通常放在finally块。2、toString 转换IO流、Uri、byte[]为String。3、copy IO流数据复制，从输入流写到输出流中，最大支持2GB。4、toByteArray 从输入流、URI获取byte[]。5、write 把字节、字符等写入输出流。6、toInputStream 把字符转换为输入流。7、readLines 从输入流中读取多行数据，返回List8、copyLarge 同copy，支持2GB以上数据的复制。9、lineIterator 从输入流返回一个迭代器，10、根据参数要求读取的数据量，全部读取，如果数据不够，则失败 org.apache.commons.io.FileUtils1、deleteDirectory 删除文件夹2、readFileToString 以字符形式读取文件内容。3、deleteQueitly 删除文件或文件夹且不会抛出异常。4、copyFile 复制文件5、writeStringToFile 把字符写到目标文件，如果文件不存在，则创建。6、forceMkdir 强制创建文件夹，如果该文件夹父级目录不存在，则创建父级。7、write 把字符写到指定文件中8、listFiles 列举某个目录下的文件(根据过滤器)9、copyDirectory 复制文件夹10、forceDelete 强制删除文件 org.apache.commons.io.FilenameUtils1、getExtension 返回文件后缀名2、getBaseName 返回文件名，不包含后缀名3、getName 返回文件全名4、concat 按命令行风格组合文件路径(详见方法注释)5、removeExtension 删除后缀名6、normalize 使路径正常化7、wildcardMatch 匹配通配符8、seperatorToUnix 路径分隔符改成unix系统格式的，即/9、getFullPath 获取文件路径，不包括文件名10、isExtension 检查文件后缀名是不是传入参数(List)中的一个 org.springframework.util.StringUtils1、hasText 检查字符串中是否包含文本2、hasLength 检测字符串是否长度大于03、isEmpty 检测字符串是否为空（若传入为对象，则判断对象是否为null）4、commaDelimitedStringToArray 逗号分隔的String转换为数组5、collectionToDelimitedString 把集合转为CSV格式字符串6、replace 替换字符串7、delimitedListToStringArray 相当于split8、uncapitalize 首字母小写9、collectionToDelimitedCommaString 把集合转为CSV格式字符串10、tokenizeToStringArray 和split基本一样，但能自动去掉空白的单词 org.apache.commons.lang.ArrayUtils1、contains 是否包含某字符串2、addAll 添加所有3、clone 克隆一个数组4、isEmpty 是否空数组5、add 向数组添加元素6、subarray 截取数组7、indexOf 查找下标8、isEquals 比较数组是否相等9、toObject 基础类型数据数组转换为对应的Object数组 org.apache.commons.codec.digest.DigestUtils1、md5Hex MD5加密，返回32位2、sha1Hex SHA-1加密3、sha256Hex SHA-256加密4、sha512Hex SHA-512加密5、md5 MD5加密，返回16位 org.apache.commons.collections.CollectionUtils1、isEmpty 是否为空2、select 根据条件筛选集合元素3、transform 根据指定方法处理集合元素，类似List的map()。4、filter 过滤元素，雷瑟List的filter()5、find 基本和select一样6、collect 和transform 差不多一样，但是返回新数组7、forAllDo 调用每个元素的指定方法。8、isEqualCollection 判断两个集合是否一致 12.JRE、JDK、JVM 及 JIT 之间有什么不同？JRE 代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用.JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。 13.ArrayList 与 LinkedList 的不区别？最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n) 14.]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDownwn基本用法]]></title>
    <url>%2F2019%2F05%2F26%2FMarkDownwn%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[是什么md是一种标记语言，通过简单的标记语法，使得普通文本具有一定的格式。有专门的编辑器打开，但我使用的是VSCode，一款很强大的编辑器，必备工具。 怎么用 文本语法 标题：用#来标志，#越多，标题等级越低； 斜体：*斜体*； 粗体：**粗体**； 斜体加粗：*** 斜体加粗 *** ； 高亮：==高亮==； 删除线：删除线； 分割线：三个—或者三个***； 引用：用&gt;即可 ; 字体颜色 ： &lt;font color=&quot;#FF0000&quot;&gt; 字体颜色 &lt;/font&gt; 代码 代码行：反括号(tab上面的键) print(hello world) 代码块：用三个反括号包起来123public void main()&#123; system.out.printin(&quot;hello&quot;);&#125; 列表 无序列表：用 * 或 + 或 - 都行，推荐用星号，注意符号后面有空格 1 无序列表1 2 无序列表2 3 无序列表3 有序列表：数字. 列表名即可，如：1.有序列表 有序列表1 有序列表2 有序列表3特别注意，有序列表的序号是根据第一行列表的数字顺序来的 链接 超链接行内式：[超链接名](超链接地址 &quot;超链接title&quot;)参数式：[超链接名]：超链接地址 &quot;超链接title&quot;示例：百度一下 图片行内式：![图片描述](图片地址 &#39;&#39;图片title&#39;&#39;)参数试：[图片描述]：图片地址 &#39;&#39;图片title&#39;&#39; 表格 1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 注：第二行分割表头和内容。有一个就行，为了对齐，多加了几个。文字默认居左；两边加：表示文字居中；右边加：表示文字居右。 防坑1. 点(.)后面要加空格； 2. #后面要加空格； 3. 换行在vscode中要空一行； 4. 关键字符转义输出，需在关键字**前**加反斜杠\。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建之路]]></title>
    <url>%2F2019%2F05%2F25%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[搭建远程博客三要素搭建个人博客=域名(外网可访问的地址)+外网服务器(外网存储文件图片的地方)+解析(本地与服务器做映射) Hexo是什么Hexo是基于JS的一个静态博客框架。静态博客：没有后端数据库加持，意味着页面上无功能模块，只能通过修改代码来修改页面功能和效果。所有文章以.md文件存储在本地电脑上。 安装Hexo框架 安装Git 安装Node.js直接去官网下载安装即可。安装完成后在命令终端输入git -vnode -vnpm -v 来检查是否安装配置成功说明：Node.js安装成功后，同时会自动安装一个包管理器，称为npm（Node Package Manager）。 npm是什么？npm是一个包管理器，发布者将自己的代码发布（npm publish）到代码仓库（registry），使用者将自己需要的包写入package.json文件中，到代码仓库中把代码下载（npm install）下来。 磁盘中新建一个文件夹Hexo/blog,我的是/d/Hexo/blog，这个路径就是以后启动 Git Bash here 的地方，以后出了问题也可以把blog文件夹下的 内容全部干掉重来。 输入如下命令：npm install -g cnpm --registry=https://registry.npm.taobao.org 完成后输入：cnpm -v 检查是否安装成功 由于npm代码仓库的服务器在国外，由于Great Firewall的缘故，下载速度可能不尽如人意，这时你可以使用淘宝的npm代码仓库，通过npm安装cnpm 下载Hexo框架到/d/Hexo/blog目录下输入命令：cnpm install -g hexo-cli 等待下载完成 本地使用 以下命令的执行路径全部都是/d/Hexo/blog 初始化一个博客，命令行输入hexo init 新建一篇博客，命令行输入hexo n &quot;我的第一篇博客&quot;这时在D:\Hexo\blog\source_posts下会生成一个我的第一篇博客.md文件，用编辑器打开即可写文章。 清理博客文件hexo clean 生成博客文件hexo g (g是generate) 启动博客文件hexo s (s是server，默认端口号是4000) 打开浏览器输入 http://localhost:4000 即可看到一个博客页面 以后修改完配置文件和写好文章后在本地 启动博客的一个流程都是123hexo cleanhexo ghexo s 远程部署一、本地+Github白嫖 生成github.io 仓库登录 github 创建仓库，仓库名称必须是 你的github账号名称.github.io 下载git部署插件，/Hexo/blog路径下命令行输入cnpm install --save hexo-deployer-git 修改站点配置_config.yaml文件deploy属性下修改为： 1234deploy: type: git repo: https://github.com/TIARAluan/TIARAluan.github.io.git branch: master 在之前本地启动的基础上加上一句 hexo d 将博客文件推到新建的github仓库中去 1234hexo cleanhexo ghexo dhexo s 部署成功后，浏览器输入 http://你的github账号名称.github.io 即可享用啦 二、买域名+租服务器]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Node.js</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java语法（持续更新···）]]></title>
    <url>%2F2019%2F03%2F30%2FJava%E8%AF%AD%E6%B3%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%C2%B7%C2%B7%C2%B7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[String类Java中将字符串作为对象来管理 1.声明字符串String str [null] eg:String s; 2.创建字符串用String类的构造方法 String（char a[]）方法123char a[]=&#123;'s','t','u','d','e','n','t'&#125;string s=new string(a,2,4)等价于String s= new String("uden") 3.连接字符串 连接多个字符串用“+”即可 连接其他数据类型结果：会将数据直接转换成字符串 4.获取字符串信息 获取长度str.length() 字符串查找 str.indexOf(substr) 返回值为索引位置 str.lastIndexOf(substr) 返回值为字符串最后出现的位置，若没有，返回-1 获取指定索引位置的字符str.charAt(int index) 5.字符串操作 获取子字符串 str.substring(int beginIndex) str.substring(int beginIndex,int endIndex) 去除空格str.trim() 字符串替换str.replace(char oldChar,char newChar) 大小写敏感，所有都会替换 判断开始与结尾str.startsWith(String prefix)`str.endWith(String suffix) 判断字符串是否相等不能简单的用==，因为比较运算符比较的是两个字符串的地址是否相同 str.equals(String otherstr) 前提是两个字符串具有相同的字符和长度 str.equalsIgnoreCase(String otherstr) 忽略大小写 按字典顺序比较两个字符串str.compareTo(String otherstr)str位于otherstr之前，返回负整数str位于otherstr之后，返回正整数相等，返回0； 大小写转换str.toLowerCase()str.toUpperCase() 字符串分割str.split(String sign)str.split(String sign,int limit) 格式化字符串str.format(String format,Object...args) 日期和时间字符串格式化Date date = new Date();String s = String.format(“%te”,date) %te表示一月中的某一天 6.正则表达式通常被用于判断语句中，用来检查某一字符串是否满足某一格式。正则表达式是含有一些具有特殊意义字符的字符串，这些字符被称为元字符 7.字符串生成器对于创建的字符串，他的长度是固定的，为了避免内存开销，产生了可变的字符序列StringBuilder类若要使StringBuilder最后输出字符串，可使用toString()方法 append()方法 用于追加内容 insert(int offset,arg)方法 用于指定位置插入数据 delete(int start,int end) 用于删除内容 练习：把字符串中的英文去掉答：使用正则表达式。元字符为\p{Alpha}把字符串倒序输出1.最容易想到的估计就是利用String类的toCharArray()，再倒序输出数组的方法2.不把字符串定义为String类，而是定义成一个StringBuffer类，用StringBuffer类中的reverse()方法直接倒序字符串]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>语法</tag>
      </tags>
  </entry>
</search>
